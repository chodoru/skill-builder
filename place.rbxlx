<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="100">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AvatarUnificationMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBXcccd7d57b1c749ea8447449d3fcc0432</Ref>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<bool name="FallHeightEnabled">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsImprovedSleep">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SandboxedInstanceMode">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<token name="TouchEventsUseCollisionGroups">0</token>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000002</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBXcccd7d57b1c749ea8447449d3fcc0432">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>27.0690022</X>
					<Y>20.5154305</Y>
					<Z>2.78427339</Z>
					<R00>-0.98228693</R00>
					<R01>-0.0330539234</R01>
					<R02>0.184444681</R02>
					<R10>-3.7252903e-09</R10>
					<R11>0.984318972</R11>
					<R12>0.176397607</R12>
					<R20>-0.187383041</R20>
					<R21>0.173273057</R21>
					<R22>-0.966883659</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>26.7001114</X>
					<Y>20.1626339</Y>
					<Z>4.7180481</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000364</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXfb976138035d4893803f7a477537055d">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">true</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ea</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX9f9879a49c184dbb906f52b960496077">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-0.0500000007</X>
					<Y>0.500003994</Y>
					<Z>-5.04999924</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000075f6</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>128</X>
					<Y>1</Y>
					<Z>128</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="TimerService" referent="RBX50afd7f4a7b1482989f0c551d31997ac">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000031d</UniqueId>
		</Properties>
	</Item>
	<Item class="SoundService" referent="92">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AudioApiByDefault">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="CharacterSoundsUseNewApi">0</token>
			<token name="DefaultListenerLocation">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsNewExpForAudioApiByDefault">false</bool>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000031e</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBXfa4c0c47e6a84c3ba960578c9eb4b3c0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000032a</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX11e62bc059054180a685539accc80cd5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000032b</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX314e9efcaba84a5190d7bcd3ff2fafe8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000032c</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXd2f683dd1cf74e54bfcd993723f0460f">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsAutoMigrated">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000331</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX0801f13d68924483a250f084faf4f8e5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BanningEnabled">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000333</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX13d35c1d9f4f49d69a221d2223f570c9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000336</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX3a6a8fe88fe94614adeaa7ffc8548bcd">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000338</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBXcde03e9a1ac941528ae3e78d925f5095">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000339</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX55bac181346d4537a31e87c15cdd8629">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="HasSeenDeprecationDialog">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000033a</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX5e1435d2eb5b41ff937c3ed535f857b1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ec</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXdcaed2cd65d047d7803aba5a935dae37">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ed</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXc925432cd307432aba350ff0615c8bb5">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ee</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
		<Item class="ChannelTabsConfiguration" referent="RBXf138c29897064e40bf06b3f58074666e">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">false</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>700</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Bold.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Color3 name="HoverBackgroundColor3">
					<R>0.490196079</R>
					<G>0.490196079</G>
					<B>0.490196079</B>
				</Color3>
				<string name="Name">ChannelTabsConfiguration</string>
				<Color3 name="SelectedTabTextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>0.686274529</R>
					<G>0.686274529</G>
					<B>0.686274529</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">1</double>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ef</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX78e4e41c0d4d4bffb10cf3372b5f00a2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000033c</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXe8f3c3e49c1841428a1cc91751e516dc">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<int name="TextElongationFactor">0</int>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000033d</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX55aebafaaa6243bfbade74de04aed29c">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000341</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="93">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_SerializedRollout">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="ClassicDeath">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<bool name="RagdollDeath">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000343</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="94">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e4</UniqueId>
			</Properties>
			<Item class="Folder" referent="95">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">TS</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e5</UniqueId>
				</Properties>
				<Item class="Folder" referent="96">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">components</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e6</UniqueId>
					</Properties>
				</Item>
				<Item class="Folder" referent="97">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">controllers</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e7</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="98">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">network</string>
						<string name="ScriptGuid">{40083a5d-587d-4d82-befb-b62eb4a54584}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network")
local GlobalEvents = _network.GlobalEvents
local GlobalFunctions = _network.GlobalFunctions
local Events = GlobalEvents:createClient({}, {
	incomingIds = {},
	incoming = {},
	incomingUnreliable = {},
	outgoingIds = {},
	outgoingUnreliable = {},
	namespaceIds = {},
	namespaces = {},
})
local Functions = GlobalFunctions:createClient({}, {
	incomingIds = {},
	incoming = {},
	outgoingIds = {},
	outgoing = {},
	namespaceIds = {},
	namespaces = {},
})
return {
	Events = Events,
	Functions = Functions,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e8</UniqueId>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="99">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">runtime</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{a980604b-4b31-4194-a393-01d1df4da6ae}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "components" } })
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "controllers" } })
Flamework._addPaths({ { "ReplicatedStorage", "TS", "components" } })
Flamework.ignite()
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e9</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX8613916480914479ac927f247847d178">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003eb</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXeb9a3a462dc74b39be379baf22d36793">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000344</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX2eef2224719746b89b03c2f359a07e6b">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<Ref name="StudioDefaultStyleSheet">null</Ref>
			<Ref name="StudioInsertWidgetLayerCollectorAutoLinkStyleSheet">null</Ref>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000345</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX8a5b06b940cf49f8ac11d181f73571eb">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000347</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX371f991fe543478ea31afbbf691baf2f">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000034c</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXd23cc36779b744928003e3270a69b9de">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000034e</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX9922e4a05d274ba39882fcd778d0799a">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000034f</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX98f50e9a8e8e413db4505a8250f28bf7">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000352</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXe8cb71f48c784fd2be1f1496f98e20f6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900007608</UniqueId>
				<string name="Value">{2b253cbc-ab87-4a9f-a07e-34e077f36b35}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX90f5f1a2868748d386c72915dfbc555c">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000353</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXb24a25331be8455ea14579606129c1e1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000354</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXb949418336574735b528b1718e01ec5a">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000355</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX7a1c0147e7c942c684b451078e3739fd">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000356</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX2dd113ea5f2c44eea56c353db4ed59f3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ControllerModels">1</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LaserPointer">1</token>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000035a</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX3a0d38f93b0f433099054186710d4d0a">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000035b</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXea4b045c64bb4e4a882564f0cd2653c6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000035c</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX3ae1fee0044d47d59a1e8011559207f5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000035d</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXfa64f839382445aba06baf5ea3205142">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000035e</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBX87fe94f54e17499b9ceeb92e18e9d566">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000036b</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX2b3d15b0622543a69f3beff65dcf66c4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000036c</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000036d</UniqueId>
		</Properties>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">TS</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000038a</UniqueId>
			</Properties>
			<Item class="Folder" referent="3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">components</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000038b</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">network</string>
					<string name="ScriptGuid">{4ddb6d93-e14d-4334-8fc1-6699b1da09d1}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Networking = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "networking", "out").Networking
local GlobalEvents = Networking.createEvent("shared/network@GlobalEvents")
local GlobalFunctions = Networking.createFunction("shared/network@GlobalFunctions")
return {
	GlobalEvents = GlobalEvents,
	GlobalFunctions = GlobalFunctions,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000038d</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXe1320ef9ff2d483db7dd152b15fb9a39">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">skills</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">31538aa351eccc22084e0a7a000078ce</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX3f264911ec1e438b8a5e9500e53d69d9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">test-skill</string>
						<string name="ScriptGuid">{281830bc-8d0c-4f67-90a1-627637b743d0}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _grabs = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "skill-actions", "grabs")
local messageReceiveAction = _grabs.messageReceiveAction
local messageSendAction = _grabs.messageSendAction
local SkillBuilder = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "skill-builder").SkillBuilder
local TestSkill = SkillBuilder.new():gotoIndex("initial"):action(messageSendAction, {
	message = "shalom",
}):async(function(s, params, prev)
	local m = prev
	print("earing in on the message", m.message)
end):call(function(s, params, prev)
	local _condition = s.data.amount
	if _condition == nil then
		_condition = 0
	end
	s.data.amount = _condition
	print("middlewared", prev)
	s:next(prev)
end):action(messageReceiveAction, nil):call(function(s)
	local willExit = math.random(1, 5) == 5
	warn("will exit?", willExit, s.data)
	local _result
	if willExit then
		_result = s:exit()
	else
		local _s = s
		local _object = {}
		local _left = "num"
		s.data.amount += 1
		_object[_left] = s.data.amount
		_object.exitNum = willExit
		_result = _s:goto("initial", _object)
	end
	return _result
end)
return {
	TestSkill = TestSkill,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6ee2b84d2b033be80850e44e00007784</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXc809313cbcdb4e1ba5fe5acc8789b36a">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">skill-actions</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6ee2b84d2b033be80850e44e0000777a</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX411e67f02fa74d8991a543816ffa2b3f">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">grabs</string>
						<string name="ScriptGuid">{548d3334-7a8f-4db1-89e0-5f52b09b2cf8}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local function messageSendAction(skillBuilder, params)
	skillBuilder:next({
		message = params.message,
	})
end
local function messageReceiveAction(skillBuilder, params, previous)
	local m = previous
	print(m.message)
	skillBuilder:next()
end
return {
	messageSendAction = messageSendAction,
	messageReceiveAction = messageReceiveAction,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6ee2b84d2b033be80850e44e00007782</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXa7e2137d451a473688e548aa370c16ef">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">skill-builder</string>
					<string name="ScriptGuid">{f47b0b5b-e849-41a8-90b0-7fde2698e39a}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "skill-builder", "main") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6ee2b84d2b033be80850e44e00007780</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX8c4010610c4c4bcba1481d998079b3ef">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">main</string>
						<string name="ScriptGuid">{e4ec26cd-a7df-4cc3-9198-2e2a8b5985ac}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Bin = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "bin", "out").Bin
local InstructionType
do
	local _inverse = {}
	InstructionType = setmetatable({}, {
		__index = _inverse,
	})
	InstructionType.Goto = 0
	_inverse[0] = "Goto"
	InstructionType.Async = 1
	_inverse[1] = "Async"
	InstructionType.Sync = 2
	_inverse[2] = "Sync"
end
local SkillBuilder
do
	SkillBuilder = setmetatable({}, {
		__tostring = function()
			return "SkillBuilder"
		end,
	})
	SkillBuilder.__index = SkillBuilder
	function SkillBuilder.new(...)
		local self = setmetatable({}, SkillBuilder)
		return self:constructor(...) or self
	end
	function SkillBuilder:constructor()
		self.sequence = {}
	end
	function SkillBuilder:getSequence()
		return self.sequence
	end
	function SkillBuilder:implSchedule(data)
		local _sequence = self.sequence
		local _data = data
		table.insert(_sequence, _data)
	end
	function SkillBuilder:action(fn, passedParams)
		self:implSchedule({
			instructionType = InstructionType.Sync,
			fn = fn,
			params = passedParams,
		})
		return self
	end
	function SkillBuilder:call(fn)
		self:implSchedule({
			instructionType = InstructionType.Sync,
			fn = fn,
			params = nil,
		})
		return self
	end
	function SkillBuilder:async(fn)
		self:implSchedule({
			instructionType = InstructionType.Async,
			fn = fn,
			params = nil,
		})
		return self
	end
	function SkillBuilder:gotoIndex(index)
		self:implSchedule({
			instructionType = InstructionType.Goto,
			fn = function(s)
				return nil
			end,
			params = {
				gotoIndex = index,
			},
		})
		return self
	end
end
local SkillRunner
do
	SkillRunner = setmetatable({}, {
		__tostring = function()
			return "SkillRunner"
		end,
	})
	SkillRunner.__index = SkillRunner
	function SkillRunner.new(...)
		local self = setmetatable({}, SkillRunner)
		return self:constructor(...) or self
	end
	function SkillRunner:constructor(builder, initParams)
		self.builder = builder
		self.initParams = initParams
		self.currentIndex = -1
		self.data = {}
		self.bin = Bin.new()
		self.sequence = builder:getSequence()
		self:next()
	end
	function SkillRunner:exit()
		self.bin:destroy()
		self.currentIndex = -1
		return nil
	end
	SkillRunner.run = TS.async(function(self, args)
		local val = self.sequence[self.currentIndex + 1]
		if val.instructionType == InstructionType.Goto then
			return self:next(args)
		end
		if val.instructionType == InstructionType.Async then
			val.fn(self, nil, args)
			return self:next(args)
		end
		val.fn(self, val.params, args)
	end)
	function SkillRunner:next(args)
		self.currentIndex += 1
		self:run(args)
		return self
	end
	function SkillRunner:goto(index, args)
		local _exp = self.sequence
		-- ▼ ReadonlyArray.findIndex ▼
		local _callback = function(v)
			local entry = v
			local _condition = entry.instructionType == InstructionType.Goto
			if _condition then
				local _result = entry.params
				if _result ~= nil then
					_result = _result.gotoIndex
				end
				_condition = _result == index
			end
			return _condition
		end
		local _result = -1
		for _i, _v in _exp do
			if _callback(_v, _i - 1, _exp) == true then
				_result = _i - 1
				break
			end
		end
		-- ▲ ReadonlyArray.findIndex ▲
		local i = _result
		local _arg0 = i > -1
		assert(_arg0, "could not perform goto, index is missing")
		self.currentIndex = i
		self:run(args)
		return self
	end
end
return {
	SkillBuilder = SkillBuilder,
	SkillRunner = SkillRunner,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6ee2b84d2b033be80850e44e0000777b</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">rbxts_include</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000391</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="10">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{b0d7ba25-f1a3-4f2f-a990-af0ecf5a74ae}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000392</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="11">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RuntimeLib</string>
					<string name="ScriptGuid">{5709bab5-08e5-4c66-91ab-6829bdebe6a7}</string>
					<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(try, catch, finally)
	-- execute try
	local trySuccess, exitTypeOrTryError, returns = pcall(try)
	local exitType, tryError
	if trySuccess then
		exitType = exitTypeOrTryError
	else
		tryError = exitTypeOrTryError
	end

	local catchSuccess = true
	local catchError

	-- if try block failed, and catch block exists, execute catch
	if not trySuccess and catch then
		local newExitTypeOrCatchError, newReturns
		catchSuccess, newExitTypeOrCatchError, newReturns = pcall(catch, tryError)
		local newExitType
		if catchSuccess then
			newExitType = newExitTypeOrCatchError
		else
			catchError = newExitTypeOrCatchError
		end

		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- execute finally
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- if exit type is a control flow, do not rethrow errors
	if exitType ~= TS.TRY_RETURN and exitType ~= TS.TRY_BREAK and exitType ~= TS.TRY_CONTINUE then
		-- if catch block threw an error, rethrow it
		if not catchSuccess then
			error(catchError, 2)
		end

		-- if try block threw an error and there was no catch block, rethrow it
		if not trySuccess and not catch then
			error(tryError, 2)
		end
	end

	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000393</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="12">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">node_modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000394</UniqueId>
				</Properties>
				<Item class="Folder" referent="13">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">@flamework</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000395</UniqueId>
					</Properties>
					<Item class="Folder" referent="14">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">components</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000396</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="15">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{32cfea4b-2b15-4ac4-a312-2a4a97a1646c}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
exports.BaseComponent = TS.import(script, script, "baseComponent").BaseComponent
local _components = TS.import(script, script, "components")
exports.Components = _components.Components
exports.ComponentStreamingMode = _components.ComponentStreamingMode
exports.Component = _components.Component
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000397</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="16">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">baseComponent</string>
									<string name="ScriptGuid">{139be704-ce74-49fc-9740-b1aca6d29c7e}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
--[[
	*
	 * @hidden @internal
	 
]]
local SYMBOL_ATTRIBUTE_HANDLERS = {}
--[[
	*
	 * @hidden @deprecated
	 
]]
local SYMBOL_ATTRIBUTE_SETTER = {}
--[[
	*
	 * This is the base component class which handles instance guards, attribute guards and cleanup.
	 *
	 * You should not construct this class manually, and all components must extend this class.
	 
]]
local BaseComponent
do
	BaseComponent = setmetatable({}, {
		__tostring = function()
			return "BaseComponent"
		end,
	})
	BaseComponent.__index = BaseComponent
	function BaseComponent.new(...)
		local self = setmetatable({}, BaseComponent)
		return self:constructor(...) or self
	end
	function BaseComponent:constructor()
		self[SYMBOL_ATTRIBUTE_HANDLERS] = {}
	end
	function BaseComponent:setInstance(component, instance, attributes)
		component.instance = instance
		component.attributes = attributes
	end
	BaseComponent[SYMBOL_ATTRIBUTE_SETTER] = function(self, key, value, postfix)
		local previousValue = (self.attributes)[key];
		(self.attributes)[key] = value
		self.instance:SetAttribute(key, value)
		return if postfix then previousValue else value
	end
	function BaseComponent:onAttributeChanged(name, cb)
		local _exp = self[SYMBOL_ATTRIBUTE_HANDLERS]
		local _name = name
		local list = _exp[_name]
		if not list then
			local _exp_1 = self[SYMBOL_ATTRIBUTE_HANDLERS]
			local _exp_2 = name
			list = Signal.new()
			local _list = list
			_exp_1[_exp_2] = _list
		end
		return list:Connect(cb)
	end
	function BaseComponent:destroy()
		for _, changeHandler in self[SYMBOL_ATTRIBUTE_HANDLERS] do
			changeHandler:Destroy()
		end
	end
end
return {
	SYMBOL_ATTRIBUTE_HANDLERS = SYMBOL_ATTRIBUTE_HANDLERS,
	SYMBOL_ATTRIBUTE_SETTER = SYMBOL_ATTRIBUTE_SETTER,
	BaseComponent = BaseComponent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000398</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="17">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">componentTracker</string>
									<string name="ScriptGuid">{7f2998be-bee5-4a3a-a456-856296565212}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local CollectionService = TS.import(script, TS.getModule(script, "@rbxts", "services")).CollectionService
local ATOMIC_MODES = {
	[Enum.ModelStreamingMode.Atomic] = true,
	[Enum.ModelStreamingMode.Persistent] = true,
	[Enum.ModelStreamingMode.PersistentPerPlayer] = true,
}
local ComponentTracker
do
	ComponentTracker = setmetatable({}, {
		__tostring = function()
			return "ComponentTracker"
		end,
	})
	ComponentTracker.__index = ComponentTracker
	function ComponentTracker.new(...)
		local self = setmetatable({}, ComponentTracker)
		return self:constructor(...) or self
	end
	function ComponentTracker:constructor(identifier, criteria)
		self.identifier = identifier
		self.criteria = criteria
		self.instances = {}
	end
	function ComponentTracker:getInstanceTracker(instance, create)
		if create == nil then
			create = true
		end
		local _instances = self.instances
		local _instance = instance
		local tracker = _instances[_instance]
		if not tracker and create then
			tracker = {
				unmetCriteria = {},
				listeners = {},
				cleanup = {},
				isQualified = true,
			}
			local _instances_1 = self.instances
			local _instance_1 = instance
			local _tracker = tracker
			_instances_1[_instance_1] = _tracker
		end
		return tracker
	end
	function ComponentTracker:updateListeners(instance, tracker)
		local isQualified = next(tracker.unmetCriteria) == nil
		if isQualified ~= tracker.isQualified then
			tracker.isQualified = isQualified
			for listener in tracker.listeners do
				listener(isQualified, instance)
			end
			local warningThread = tracker.timeoutWarningThread
			if isQualified and warningThread then
				tracker.timeoutWarningThread = nil
				task.cancel(warningThread)
			end
		end
	end
	function ComponentTracker:setupTracker(instance, tracker)
		local _binding = self.criteria
		local typeGuard = _binding.typeGuard
		local typeGuardPoll = _binding.typeGuardPoll
		local typeGuardPollAtomic = _binding.typeGuardPollAtomic
		local dependencies = _binding.dependencies
		local _condition = instance:IsA("Model")
		if _condition then
			local _modelStreamingMode = instance.ModelStreamingMode
			_condition = ATOMIC_MODES[_modelStreamingMode] ~= nil
		end
		local isAtomicModel = _condition
		if typeGuard and typeGuardPoll and (typeGuardPollAtomic or not isAtomicModel) then
			local addedConnection
			local removingConnection
			local connectRemoving
			local connectAdded = function()
				if removingConnection then
					removingConnection:Disconnect()
					removingConnection = nil
				end
				local isScheduled = false
				addedConnection = instance.DescendantAdded:Connect(function()
					if not isScheduled then
						isScheduled = true
						task.defer(function()
							isScheduled = false
							if typeGuard(instance) then
								connectRemoving()
								tracker.unmetCriteria["type guard"] = nil
								self:updateListeners(instance, tracker)
							end
						end)
					end
				end)
			end
			connectRemoving = function()
				if addedConnection then
					addedConnection:Disconnect()
					addedConnection = nil
				end
				local isScheduled = false
				removingConnection = instance.DescendantRemoving:Connect(function()
					if not isScheduled then
						isScheduled = true
						task.defer(function()
							isScheduled = false
							if not typeGuard(instance) then
								connectAdded()
								tracker.unmetCriteria["type guard"] = true
								self:updateListeners(instance, tracker)
							end
						end)
					end
				end)
			end
			tracker.cleanup[function()
				local _result = addedConnection
				if _result ~= nil then
					_result:Disconnect()
				end
				local _result_1 = removingConnection
				if _result_1 ~= nil then
					_result_1:Disconnect()
				end
			end] = true
			if tracker.unmetCriteria["type guard"] ~= nil then
				connectAdded()
			else
				connectRemoving()
			end
		end
		if dependencies then
			for _, dependency in dependencies do
				local listener = function(isQualified)
					if isQualified then
						tracker.unmetCriteria[dependency] = nil
					else
						tracker.unmetCriteria[dependency] = true
					end
					self:updateListeners(instance, tracker)
				end
				dependency:trackInstance(instance, listener)
				tracker.cleanup[function()
					dependency:untrackInstance(instance, listener)
				end] = true
			end
		end
		if not tracker.isQualified and self.criteria.warningTimeout ~= 0 then
			local _condition_1 = self.criteria.warningTimeout
			if _condition_1 == nil then
				_condition_1 = 5
			end
			tracker.timeoutWarningThread = task.delay(_condition_1, function()
				local reasons = {}
				for criteria in tracker.unmetCriteria do
					if type(criteria) == "string" then
						table.insert(reasons, criteria)
					end
				end
				if dependencies then
					for _, dependency in dependencies do
						if tracker.unmetCriteria[dependency] ~= nil then
							local _arg0 = `dependency '{dependency.identifier}'`
							table.insert(reasons, _arg0)
						end
					end
				end
				warn(`[Flamework] Infinite yield possible on instance '{instance:GetFullName()}'`)
				warn(`Waiting for component '{self.identifier}'`)
				warn(`Waiting for the following criteria: {table.concat(reasons, ", ")}`)
			end)
		end
	end
	function ComponentTracker:testInstance(instance, tracker)
		local result = true
		if self.criteria.dependencies then
			for _, dependency in self.criteria.dependencies do
				if not dependency:checkInstance(instance) then
					result = false
					if tracker then
						tracker.unmetCriteria[dependency] = true
						self:updateListeners(instance, tracker)
					else
						return result
					end
				end
			end
		end
		if self.criteria.typeGuard then
			if not self.criteria.typeGuard(instance) then
				result = false
				if tracker then
					tracker.unmetCriteria["type guard"] = true
					self:updateListeners(instance, tracker)
				else
					return result
				end
			end
		end
		if self.criteria.tag ~= nil then
			if not CollectionService:HasTag(instance, self.criteria.tag) then
				result = false
				if tracker then
					tracker.unmetCriteria["CollectionService tag"] = true
					self:updateListeners(instance, tracker)
				else
					return result
				end
			end
		end
		return result
	end
	function ComponentTracker:setHasTag(instance, hasTag)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			if hasTag then
				tracker.unmetCriteria["CollectionService tag"] = nil
			else
				tracker.unmetCriteria["CollectionService tag"] = true
			end
			self:updateListeners(instance, tracker)
		end
	end
	function ComponentTracker:checkInstance(instance)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			return tracker.isQualified
		end
		return self:testInstance(instance, tracker)
	end
	function ComponentTracker:isTracked(instance)
		local _instances = self.instances
		local _instance = instance
		return _instances[_instance] ~= nil
	end
	function ComponentTracker:trackInstance(instance, listener)
		local _instances = self.instances
		local _instance = instance
		local isNewInstance = not (_instances[_instance] ~= nil)
		local tracker = self:getInstanceTracker(instance)
		if isNewInstance then
			self:testInstance(instance, tracker)
			self:setupTracker(instance, tracker)
		end
		local _listeners = tracker.listeners
		local _listener = listener
		_listeners[_listener] = true
		listener(tracker.isQualified, instance)
	end
	function ComponentTracker:untrackInstance(instance, listener)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			local _listeners = tracker.listeners
			local _listener = listener
			_listeners[_listener] = nil
			if next(tracker.listeners) == nil then
				for cleanup in tracker.cleanup do
					cleanup()
				end
				local _instances = self.instances
				local _instance = instance
				_instances[_instance] = nil
			end
		end
	end
end
return {
	ComponentTracker = ComponentTracker,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000399</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="18">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">components</string>
									<string name="ScriptGuid">{c8ea393d-6d71-47a4-9688-a158fd546042}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _core = TS.import(script, TS.getModule(script, "@flamework", "core").out)
local Controller = _core.Controller
local Flamework = _core.Flamework
local Modding = _core.Modding
local Reflect = _core.Reflect
local Service = _core.Service
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local CollectionService = _services.CollectionService
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local ServerStorage = _services.ServerStorage
local StarterGui = _services.StarterGui
local StarterPack = _services.StarterPack
local StarterPlayer = _services.StarterPlayer
local _baseComponent = TS.import(script, script.Parent, "baseComponent")
local BaseComponent = _baseComponent.BaseComponent
local SYMBOL_ATTRIBUTE_HANDLERS = _baseComponent.SYMBOL_ATTRIBUTE_HANDLERS
local ComponentTracker = TS.import(script, script.Parent, "componentTracker").ComponentTracker
local _utility = TS.import(script, script.Parent, "utility")
local getComponentFromSpecifier = _utility.getComponentFromSpecifier
local getIdFromSpecifier = _utility.getIdFromSpecifier
local getParentConstructor = _utility.getParentConstructor
local isConstructor = _utility.isConstructor
local safeCall = _utility.safeCall
local Maid = TS.import(script, TS.getModule(script, "@rbxts", "maid").Maid)
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
--[[
	*
	 * This enum dictates how component instance guards interact with StreamingEnabled.
	 
]]
local ComponentStreamingMode
do
	local _inverse = {}
	ComponentStreamingMode = setmetatable({}, {
		__index = _inverse,
	})
	ComponentStreamingMode.Disabled = 0
	_inverse[0] = "Disabled"
	ComponentStreamingMode.Watching = 1
	_inverse[1] = "Watching"
	ComponentStreamingMode.Contextual = 2
	_inverse[2] = "Contextual"
	ComponentStreamingMode.Default = 2
	_inverse[2] = "Default"
end
local DEFAULT_ANCESTOR_BLACKLIST = { ServerStorage, ReplicatedStorage, StarterPack, StarterGui, StarterPlayer }
--[[
	*
	 * Register a class as a Component.
	 *
	 * @metadata flamework:implements flamework:parameters injectable intrinsic-component-decorator
	 
]]
local Component = Modding.createMetaDecorator("Class")
--[[
	*
	 * This class is responsible for loading and managing
	 * all components in the game.
	 
]]
local Components
do
	Components = setmetatable({}, {
		__tostring = function()
			return "Components"
		end,
	})
	Components.__index = Components
	function Components.new(...)
		local self = setmetatable({}, Components)
		return self:constructor(...) or self
	end
	function Components:constructor()
		self.components = {}
		self.classParentCache = {}
		self.activeComponents = {}
		self.activeInheritedComponents = {}
		self.reverseComponentsMapping = {}
		self.componentConstructing = {}
		self.trackers = {}
		self.componentWaiters = {}
		self.componentCleanup = {}
		self.componentAddedListeners = {}
		self.componentRemovedListeners = {}
	end
	function Components:onInit()
		local components = {}
		local componentConstructors = Modding.getDecorators("$c:components@Component")
		for _, _binding in componentConstructors do
			local ctor = _binding.constructor
			local args = _binding.arguments
			if ctor == nil then
				continue
			end
			local identifier = Reflect.getMetadata(ctor, "identifier")
			local componentDependencies = {}
			local parameters = Reflect.getMetadata(ctor, "flamework:parameters")
			if parameters then
				for _1, dependency in parameters do
					local object = Modding.getObjectFromId(dependency)
					if not object or not isConstructor(object) then
						continue
					end
					if not Modding.getDecorator(object, nil, "$c:components@Component") then
						continue
					end
					table.insert(componentDependencies, object)
				end
			end
			local _arg1 = {
				ctor = ctor,
				config = args[1] or {},
				polymorphicIds = self:getPolymorphicIds(ctor),
				componentDependencies = componentDependencies,
				identifier = identifier,
			}
			components[ctor] = _arg1
		end
		self.components = components
	end
	function Components:onStart()
		for _, _binding in self.components do
			local config = _binding.config
			local ctor = _binding.ctor
			local ancestorBlacklist = config.ancestorBlacklist or DEFAULT_ANCESTOR_BLACKLIST
			local ancestorWhitelist = config.ancestorWhitelist
			if config.tag ~= nil then
				local tracker = self:getComponentTracker(ctor)
				local predicate = self:getConfigValue(ctor, "predicate")
				local listener = function(isQualified, instance)
					if isQualified then
						self:addComponent(instance, ctor, true)
					else
						self:removeComponent(instance, ctor)
					end
				end
				local instanceAdded = function(instance)
					if predicate ~= nil and not predicate(instance) then
						return nil
					end
					local _isWhitelisted = ancestorWhitelist
					if _isWhitelisted ~= nil then
						-- ▼ ReadonlyArray.some ▼
						local _result = false
						local _callback = function(ancestor)
							return instance:IsDescendantOf(ancestor)
						end
						for _k, _v in _isWhitelisted do
							if _callback(_v, _k - 1, _isWhitelisted) then
								_result = true
								break
							end
						end
						-- ▲ ReadonlyArray.some ▲
						_isWhitelisted = _result
					end
					local isWhitelisted = _isWhitelisted
					if isWhitelisted == false then
						return nil
					end
					-- ▼ ReadonlyArray.some ▼
					local _result = false
					local _callback = function(ancestor)
						return instance:IsDescendantOf(ancestor)
					end
					for _k, _v in ancestorBlacklist do
						if _callback(_v, _k - 1, ancestorBlacklist) then
							_result = true
							break
						end
					end
					-- ▲ ReadonlyArray.some ▲
					local isBlacklisted = _result
					if isBlacklisted and isWhitelisted == nil then
						return nil
					end
					tracker:trackInstance(instance, listener)
					tracker:setHasTag(instance, true)
				end
				CollectionService:GetInstanceAddedSignal(config.tag):Connect(instanceAdded)
				CollectionService:GetInstanceRemovedSignal(config.tag):Connect(function(instance)
					tracker:untrackInstance(instance, listener)
					tracker:setHasTag(instance, false)
					self:removeComponent(instance, ctor)
				end)
				for _1, instance in CollectionService:GetTagged(config.tag) do
					safeCall({ `[Flamework] Failed to instantiate '{ctor}' for`, instance, `[{instance:GetFullName()}]` }, function()
						return instanceAdded(instance)
					end, false)
				end
			end
		end
	end
	function Components:getComponentTracker(component)
		local _trackers = self.trackers
		local _component = component
		local existingTracker = _trackers[_component]
		if existingTracker then
			return existingTracker
		end
		local _components = self.components
		local _component_1 = component
		local componentInfo = _components[_component_1]
		assert(componentInfo, "Provided component does not exist")
		local instanceGuard = self:getConfigValue(component, "instanceGuard")
		local dependencies = {}
		for _, dependency in componentInfo.componentDependencies do
			local _arg0 = self:getComponentTracker(dependency)
			table.insert(dependencies, _arg0)
		end
		local _condition = componentInfo.config.streamingMode
		if _condition == nil then
			_condition = ComponentStreamingMode.Default
		end
		local streamingMode = _condition
		local tracker = ComponentTracker.new(componentInfo.identifier, {
			tag = componentInfo.config.tag,
			typeGuard = instanceGuard,
			typeGuardPoll = (streamingMode == ComponentStreamingMode.Contextual and RunService:IsClient()) or streamingMode == ComponentStreamingMode.Watching,
			typeGuardPollAtomic = streamingMode ~= ComponentStreamingMode.Contextual,
			warningTimeout = componentInfo.config.warningTimeout,
			dependencies = dependencies,
		})
		local _trackers_1 = self.trackers
		local _component_2 = component
		_trackers_1[_component_2] = tracker
		return tracker
	end
	function Components:getOrderedParents(ctor, omitBaseComponent)
		if omitBaseComponent == nil then
			omitBaseComponent = true
		end
		local _classParentCache = self.classParentCache
		local _ctor = ctor
		local cache = _classParentCache[_ctor]
		if cache then
			return cache
		end
		local classes = { ctor }
		local nextParent = ctor
		while true do
			nextParent = getParentConstructor(nextParent)
			if not (nextParent ~= nil) then
				break
			end
			if not omitBaseComponent or nextParent ~= BaseComponent then
				local _nextParent = nextParent
				table.insert(classes, _nextParent)
			end
		end
		local _classParentCache_1 = self.classParentCache
		local _ctor_1 = ctor
		_classParentCache_1[_ctor_1] = classes
		return classes
	end
	function Components:getAttributeGuards(ctor)
		local attributes = {}
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config.attributes ~= nil then
				for attribute, guard in pairs(metadata.config.attributes) do
					attributes[attribute] = guard
				end
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				for attribute, guard in self:getAttributeGuards(parentCtor.__index) do
					if not (attributes[attribute] ~= nil) then
						attributes[attribute] = guard
					end
				end
			end
		end
		return attributes
	end
	function Components:getAttributes(instance, componentInfo, guards)
		local attributes = instance:GetAttributes()
		local newAttributes = {}
		local defaults = self:getConfigValue(componentInfo.ctor, "defaults")
		for key, guard in pairs(guards) do
			local attribute = attributes[key]
			if not guard(attribute) then
				local _result = defaults
				if _result ~= nil then
					_result = _result[key]
				end
				if _result ~= nil then
					local _arg1 = defaults[key]
					newAttributes[key] = _arg1
					instance:SetAttribute(key, defaults[key])
				else
					error(`{instance:GetFullName()} has invalid attribute '{key}' for '{componentInfo.identifier}'`)
				end
			else
				newAttributes[key] = attribute
			end
		end
		return newAttributes
	end
	function Components:getConfigValue(ctor, key)
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config[key] ~= nil then
				return metadata.config[key]
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				return self:getConfigValue(parentCtor.__index, key)
			end
		end
	end
	function Components:setupComponent(instance, attributes, component, construct, _param)
		local ctor = _param.ctor
		BaseComponent:setInstance(component, instance, attributes)
		construct()
		if Flamework._implements(component, "$:flamework@OnStart") then
			safeCall({ `[Flamework] Component '{ctor}' failed to start for`, instance, `[{instance:GetFullName()}]` }, function()
				return component:onStart()
			end)
		end
		Modding.addListener(component)
		local maid = Maid.new()
		local _componentCleanup = self.componentCleanup
		local _component = component
		_componentCleanup[_component] = maid
		maid:GiveTask(function()
			return Modding.removeListener(component)
		end)
		local refreshAttributes = self:getConfigValue(ctor, "refreshAttributes")
		if refreshAttributes == nil or refreshAttributes then
			local attributeCache = table.clone(attributes)
			local attributeGuards = self:getAttributeGuards(ctor)
			for attribute, guard in pairs(attributeGuards) do
				if type(attribute) == "string" then
					maid:GiveTask(instance:GetAttributeChangedSignal(attribute):Connect(function()
						local signal = component[SYMBOL_ATTRIBUTE_HANDLERS][attribute]
						local value = instance:GetAttribute(attribute)
						local attributes = component.attributes
						if guard(value) then
							attributes[attribute] = value
							local _result = signal
							if _result ~= nil then
								_result:Fire(value, attributeCache[attribute])
							end
							attributeCache[attribute] = value
						end
					end))
				end
			end
		end
		local _componentWaiters = self.componentWaiters
		local _instance = instance
		local instanceWaiters = _componentWaiters[_instance]
		local _componentWaiters_1 = instanceWaiters
		if _componentWaiters_1 ~= nil then
			_componentWaiters_1 = _componentWaiters_1[ctor]
		end
		local componentWaiters = _componentWaiters_1
		if componentWaiters then
			instanceWaiters[ctor] = nil
			-- ▼ ReadonlyMap.size ▼
			local _size = 0
			for _ in instanceWaiters do
				_size += 1
			end
			-- ▲ ReadonlyMap.size ▲
			if _size == 0 then
				local _componentWaiters_2 = self.componentWaiters
				local _instance_1 = instance
				_componentWaiters_2[_instance_1] = nil
			end
			for waiter in componentWaiters do
				waiter(component)
			end
		end
	end
	function Components:addIdMapping(value, id, inheritedComponents)
		local _inheritedComponents = inheritedComponents
		local _id = id
		local instances = _inheritedComponents[_id]
		if not instances then
			local _inheritedComponents_1 = inheritedComponents
			local _exp = id
			instances = {}
			local _instances = instances
			_inheritedComponents_1[_exp] = _instances
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _exp = id
			inheritedLookup = {}
			local _inheritedLookup = inheritedLookup
			_reverseComponentsMapping_1[_exp] = _inheritedLookup
		end
		local _instances = instances
		local _value = value
		_instances[_value] = true
		local _inheritedLookup = inheritedLookup
		local _value_1 = value
		_inheritedLookup[_value_1] = true
	end
	function Components:removeIdMapping(instance, value, id)
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local inheritedComponents = _activeInheritedComponents[_instance]
		if not inheritedComponents then
			return nil
		end
		local _id = id
		local instances = inheritedComponents[_id]
		if not instances then
			return nil
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			return nil
		end
		local _value = value
		instances[_value] = nil
		local _value_1 = value
		inheritedLookup[_value_1] = nil
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in inheritedLookup do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size == 0 then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _id_2 = id
			_reverseComponentsMapping_1[_id_2] = nil
		end
		-- ▼ ReadonlySet.size ▼
		local _size_1 = 0
		for _ in instances do
			_size_1 += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size_1 == 0 then
			local _id_2 = id
			inheritedComponents[_id_2] = nil
		end
		-- ▼ ReadonlyMap.size ▼
		local _size_2 = 0
		for _ in inheritedComponents do
			_size_2 += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size_2 == 0 then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _instance_1 = instance
			_activeInheritedComponents_1[_instance_1] = nil
		end
	end
	function Components:canCreateComponentEager(instance, component)
		local _components = self.components
		local _component = component
		local componentInfo = _components[_component]
		if not componentInfo then
			return false
		end
		if componentInfo.config.predicate and not componentInfo.config.predicate(instance) then
			return false
		end
		local tag = componentInfo.config.tag
		if tag ~= nil and instance.Parent and CollectionService:HasTag(instance, tag) then
			local tracker = self:getComponentTracker(component)
			return tracker:checkInstance(instance)
		end
	end
	function Components:getDependencyResolutionOptions(componentInfo, instance)
		if #componentInfo.componentDependencies == 0 then
			return nil
		end
		return {
			handle = function(id)
				local ctor = Modding.getObjectFromId(id)
				if ctor and isConstructor(ctor) and Modding.getDecorator(ctor, nil, "$c:components@Component") then
					local component = self:getComponent(instance, ctor)
					if component == nil then
						local name = instance:GetFullName()
						error(`Could not resolve component '{id}' while constructing '{componentInfo.identifier}' ({name})`)
					end
					return component
				end
			end,
		}
	end
	function Components:getPolymorphicIds(component)
		local ids = {}
		for _, parentClass in self:getOrderedParents(component) do
			local parentId = Reflect.getOwnMetadata(parentClass, "identifier")
			if parentId == nil then
				continue
			end
			table.insert(ids, parentId)
		end
		local implementedList = Reflect.getMetadatas(component, "flamework:implements")
		for _, implemented in implementedList do
			for _1, id in implemented do
				table.insert(ids, id)
			end
		end
		return ids
	end
	function Components:getComponent(instance, componentSpecifier)
		local component = getComponentFromSpecifier(componentSpecifier)
		local _arg1 = `Could not find component from specifier: {componentSpecifier}`
		assert(component, _arg1)
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if activeComponents then
			local activeComponent = activeComponents[component]
			if activeComponent then
				-- The component is still being constructed.
				if self.componentConstructing[activeComponent] ~= nil then
					return nil
				end
				return activeComponent
			end
		end
		if self:canCreateComponentEager(instance, component) then
			return self:addComponent(instance, component, true)
		end
	end
	function Components:getComponents(instance, componentSpecifier)
		local componentIdentifier = getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local activeComponents = _activeInheritedComponents[_instance]
		if not activeComponents then
			return {}
		end
		local componentsSet = activeComponents[componentIdentifier]
		if not componentsSet then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in componentsSet do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	function Components:addComponent(instance, componentSpecifier, skipInstanceCheck)
		local component = getComponentFromSpecifier(componentSpecifier)
		local _arg1 = `Could not find component from specifier: {componentSpecifier}`
		assert(component, _arg1)
		local componentInfo = self.components[component]
		assert(componentInfo, "Provided componentSpecifier does not exist")
		local attributeGuards = self:getAttributeGuards(component)
		local attributes = self:getAttributes(instance, componentInfo, attributeGuards)
		if skipInstanceCheck ~= true then
			local instanceGuard = self:getConfigValue(component, "instanceGuard")
			if instanceGuard ~= nil then
				local _arg0 = instanceGuard(instance)
				local _arg1_1 = `{instance:GetFullName()} did not pass instance guard check for '{componentInfo.identifier}'`
				assert(_arg0, _arg1_1)
			end
		end
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			local _activeComponents_1 = self.activeComponents
			local _exp = instance
			activeComponents = {}
			local _activeComponents_2 = activeComponents
			_activeComponents_1[_exp] = _activeComponents_2
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance_1 = instance
		local inheritedComponents = _activeInheritedComponents[_instance_1]
		if not inheritedComponents then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _exp = instance
			inheritedComponents = {}
			local _inheritedComponents = inheritedComponents
			_activeInheritedComponents_1[_exp] = _inheritedComponents
		end
		local existingComponent = activeComponents[component]
		if existingComponent ~= nil then
			-- The component has already been added, but is still being constructed.
			if self.componentConstructing[existingComponent] ~= nil then
				error("component is cyclic, attempted to construct component while it is already being constructed.")
			end
			return existingComponent
		end
		local resolutionOptions = self:getDependencyResolutionOptions(componentInfo, instance)
		local _binding = Modding.createDeferredDependency(component, resolutionOptions)
		local componentInstance = _binding[1]
		local construct = _binding[2]
		self.componentConstructing[componentInstance] = true
		activeComponents[component] = componentInstance
		self:setupComponent(instance, attributes, componentInstance, construct, componentInfo)
		self.componentConstructing[componentInstance] = nil
		for _, id in componentInfo.polymorphicIds do
			self:addIdMapping(componentInstance, id, inheritedComponents)
			local signal = self.componentAddedListeners[id]
			if signal then
				signal:Fire(componentInstance, instance)
			end
		end
		return componentInstance
	end
	function Components:removeComponent(instance, componentSpecifier)
		local component = getComponentFromSpecifier(componentSpecifier)
		local _arg1 = `Could not find component from specifier: {componentSpecifier}`
		assert(component, _arg1)
		local componentInfo = self.components[component]
		assert(componentInfo, "Provided componentSpecifier does not exist")
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			return nil
		end
		local existingComponent = activeComponents[component]
		if not existingComponent then
			return nil
		end
		for _, id in componentInfo.polymorphicIds do
			local signal = self.componentRemovedListeners[id]
			if signal then
				signal:Fire(existingComponent, instance)
			end
		end
		existingComponent:destroy()
		activeComponents[component] = nil
		for _, id in componentInfo.polymorphicIds do
			self:removeIdMapping(instance, existingComponent, id)
		end
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in activeComponents do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size == 0 then
			local _activeComponents_1 = self.activeComponents
			local _instance_1 = instance
			_activeComponents_1[_instance_1] = nil
		end
		local maid = self.componentCleanup[existingComponent]
		self.componentCleanup[existingComponent] = nil
		if maid ~= nil then
			maid:Destroy()
		end
	end
	function Components:getAllComponents(componentSpecifier)
		local componentIdentifier = getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local reverseMapping = self.reverseComponentsMapping[componentIdentifier]
		if not reverseMapping then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in reverseMapping do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	function Components:waitForComponent(instance, componentSpecifier)
		local component = getComponentFromSpecifier(componentSpecifier)
		local _arg1 = `Could not find component from specifier: {componentSpecifier}`
		assert(component, _arg1)
		return TS.Promise.new(function(resolve, _, onCancel)
			local existingComponent = self:getComponent(instance, componentSpecifier)
			if existingComponent ~= nil then
				return resolve(existingComponent)
			end
			local _componentWaiters = self.componentWaiters
			local _instance = instance
			local instanceWaiters = _componentWaiters[_instance]
			if not instanceWaiters then
				local _componentWaiters_1 = self.componentWaiters
				local _exp = instance
				instanceWaiters = {}
				local _instanceWaiters = instanceWaiters
				_componentWaiters_1[_exp] = _instanceWaiters
			end
			local componentWaiters = instanceWaiters[component]
			if not componentWaiters then
				local _instanceWaiters = instanceWaiters
				componentWaiters = {}
				local _componentWaiters_1 = componentWaiters
				_instanceWaiters[component] = _componentWaiters_1
			end
			onCancel(function()
				local _componentWaiters_1 = componentWaiters
				local _resolve = resolve
				_componentWaiters_1[_resolve] = nil
				-- ▼ ReadonlySet.size ▼
				local _size = 0
				for _1 in componentWaiters do
					_size += 1
				end
				-- ▲ ReadonlySet.size ▲
				if _size == 0 then
					instanceWaiters[component] = nil
				end
				-- ▼ ReadonlyMap.size ▼
				local _size_1 = 0
				for _1 in instanceWaiters do
					_size_1 += 1
				end
				-- ▲ ReadonlyMap.size ▲
				if _size_1 == 0 then
					local _componentWaiters_2 = self.componentWaiters
					local _instance_1 = instance
					_componentWaiters_2[_instance_1] = nil
				end
			end)
			local _componentWaiters_1 = componentWaiters
			local _resolve = resolve
			_componentWaiters_1[_resolve] = true
		end)
	end
	function Components:onComponentAdded(callback, componentSpecifier)
		local componentId = getIdFromSpecifier(componentSpecifier)
		local _arg0 = componentId ~= nil
		assert(_arg0)
		local signal = self.componentAddedListeners[componentId]
		if not signal then
			local _componentAddedListeners = self.componentAddedListeners
			signal = Signal.new()
			local _signal = signal
			_componentAddedListeners[componentId] = _signal
		end
		return signal:Connect(callback)
	end
	function Components:onComponentRemoved(callback, componentSpecifier)
		local componentId = getIdFromSpecifier(componentSpecifier)
		local _arg0 = componentId ~= nil
		assert(_arg0)
		local signal = self.componentRemovedListeners[componentId]
		if not signal then
			local _componentRemovedListeners = self.componentRemovedListeners
			signal = Signal.new()
			local _signal = signal
			_componentRemovedListeners[componentId] = _signal
		end
		return signal:Connect(callback)
	end
	do
		-- (Flamework) Components metadata
		Reflect.defineMetadata(Components, "identifier", "$c:components@Components")
		Reflect.defineMetadata(Components, "flamework:implements", { "$:flamework@OnInit", "$:flamework@OnStart" })
	end
end
-- (Flamework) Components decorators
Reflect.decorate(Components, "$:flamework@Controller", Controller, { {
	loadOrder = 0,
} })
Reflect.decorate(Components, "$:flamework@Service", Service, { {
	loadOrder = 0,
} })
return {
	ComponentStreamingMode = ComponentStreamingMode,
	Component = Component,
	Components = Components,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="19">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">utility</string>
									<string name="ScriptGuid">{ed1cb7e1-56af-4108-8467-2a3b32df078a}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _core = TS.import(script, TS.getModule(script, "@flamework", "core").out)
local Modding = _core.Modding
local Reflect = _core.Reflect
local function isConstructor(obj)
	return obj.constructor ~= nil and obj.new ~= nil
end
local function getParentConstructor(ctor)
	local metatable = getmetatable(ctor)
	if metatable and type(metatable) == "table" then
		local parentConstructor = rawget(metatable, "__index")
		return parentConstructor
	end
end
local function safeCall(message, func, printStack)
	if printStack == nil then
		printStack = true
	end
	task.spawn(function()
		xpcall(func, function(err)
			local _err = err
			local _condition = type(_err) == "string"
			if _condition then
				_condition = printStack
			end
			if _condition then
				local stack = debug.traceback(err, 2)
				warn(unpack(message))
				warn(stack)
			else
				warn(unpack(message))
				warn(err)
				if printStack then
					warn(debug.traceback(nil, 2))
				end
			end
		end)
	end)
end
local function getComponentFromSpecifier(componentSpecifier)
	local _componentSpecifier = componentSpecifier
	return if type(_componentSpecifier) == "string" then (Modding.getObjectFromId(componentSpecifier)) else componentSpecifier
end
local function getIdFromSpecifier(componentSpecifier)
	if componentSpecifier ~= nil then
		local _componentSpecifier = componentSpecifier
		return if type(_componentSpecifier) == "string" then componentSpecifier else Reflect.getMetadata(componentSpecifier, "identifier")
	end
end
return {
	isConstructor = isConstructor,
	getParentConstructor = getParentConstructor,
	safeCall = safeCall,
	getComponentFromSpecifier = getComponentFromSpecifier,
	getIdFromSpecifier = getIdFromSpecifier,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039b</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXfac8ba82096c4741ba3a1f5aae4e2d3a">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">node_modules</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4db7e10cda041d1f085077e100007e68</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXa6ab3688b6214c50bcde26ad855dd989">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">@rbxts</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4db7e10cda041d1f085077e100007e69</UniqueId>
								</Properties>
								<Item class="Folder" referent="RBX9f7915ae5d7348c9922a51a5d5baf327">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">t</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4db7e10cda041d1f085077e100007e6a</UniqueId>
									</Properties>
									<Item class="Folder" referent="RBX270cc7fd109d4ee1b23aaa6bc329fcf6">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">lib</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">4db7e10cda041d1f085077e100007e6b</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="RBX6150780239694e7087f937a69e5d9da0">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ts</string>
												<string name="ScriptGuid">{c5694ccb-0063-442a-a325-9c2d0785c388}</string>
												<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">4db7e10cda041d1f085077e100007e6c</UniqueId>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="20">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">core</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039c</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="21">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{f7b9a8e5-9516-4f17-ba80-91b627e9acef}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
exports.Reflect = TS.import(script, script, "reflect").Reflect
exports.Modding = TS.import(script, script, "modding").Modding
local _flamework = TS.import(script, script, "flamework")
exports.Controller = _flamework.Controller
exports.Dependency = _flamework.Dependency
exports.Optional = _flamework.Optional
exports.Service = _flamework.Service
exports.Flamework = _flamework.Flamework
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039d</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="22">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">flamework</string>
									<string name="ScriptGuid">{751f3c6c-c076-4b1a-9928-72fe7b25a257}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Metadata = TS.import(script, script.Parent, "metadata").Metadata
local Modding = TS.import(script, script.Parent, "modding").Modding
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	-- RuntimeLib, which is required to import packages
	local tsImpl = _G[script]
	local isProfiling = Metadata.isProfiling()
	local hasFlameworkIgnited = false
	local isPreloading = false
	local inactiveThread
	--* @hidden 
	local function resolveDependency(id)
		if isPreloading then
			local source, line = debug.info(2, "sl")
			warn(`[Flamework] Attempting to load dependency '{id}' during preloading.`)
			warn("This is prone to race conditions and is not guaranteed to succeed.")
			warn(`Script '{source}', Line {line}`)
		elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then
			local source, line = debug.info(2, "sl")
			warn(`[Flamework] Dependency '{id}' was loaded before ignition.`)
			warn("This is considered bad practice and should be avoided.")
			warn("You can disable this warning in flamework.json")
			warn(`Script '{source}', Line {line}`)
		end
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	--* @hidden 
	local logIfVerbose
	local function _addPaths(paths)
		local preloadPaths = {}
		for _, arg in paths do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			for i = 0, #arg - 1 do
				currentPath = currentPath:WaitForChild(arg[i + 1])
			end
			local _currentPath = currentPath
			table.insert(preloadPaths, _currentPath)
		end
		local preload = function(moduleScript)
			isPreloading = true
			local start = os.clock()
			local success, value = pcall(function()
				return tsImpl.import(script, moduleScript)
			end)
			local endTime = math.floor((os.clock() - start) * 1000)
			isPreloading = false
			if not success then
				error(`{moduleScript:GetFullName()} failed to preload ({endTime}ms): {value}`)
			end
		end
		for _, path in preloadPaths do
			logIfVerbose(`Preloading directory {path:GetFullName()}`)
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _1, instance in path:GetDescendants() do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	--* @hidden 
	local function _addPathsGlob(arg)
		return _addPaths(Metadata.getGlob(arg) or {})
	end
	_container._addPathsGlob = _addPathsGlob
	--* @hidden 
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		local _callback = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	function logIfVerbose(...)
		local args = { ... }
		if Metadata.getLogLevel() == "verbose" then
			print("[Flamework (verbose)]", unpack(args))
		end
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = `UnidentifiedFlameworkListener{suffix}`
		end
		return _condition
	end
	-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.
	local function topologicalSort(objects)
		-- This implementation ignores circular dependency trees.
		local currentSize = 0
		local sorted = {}
		local visited = {}
		local visitor
		visitor = function(node)
			local _node = node
			if visited[_node] ~= nil then
				return nil
			end
			local _node_1 = node
			visited[_node_1] = true
			local _idToObj = Reflect.idToObj
			local _node_2 = node
			local object = _idToObj[_node_2]
			if not object then
				return nil
			end
			local dependencies = Reflect.getMetadata(object, "flamework:parameters")
			for _, dependency in dependencies or {} do
				visitor(dependency)
			end
			local _exp = node
			local _original = currentSize
			currentSize += 1
			sorted[_exp] = _original
		end
		for _, node in objects do
			visitor(node)
		end
		return sorted
	end
	local function reusableThread(func)
		local thread = coroutine.running()
		while true do
			if inactiveThread == thread then
				inactiveThread = nil
			end
			func()
			-- If there's a different idle thread, we should end the current thread.
			if inactiveThread ~= nil then
				break
			end
			inactiveThread = thread
			func = coroutine.yield()
		end
	end
	local function profileYielding(func, identifier)
		if isProfiling then
			return function()
				-- `profilebegin` will end when this thread dies or yields.
				debug.profilebegin(identifier)
				debug.setmemorycategory(identifier)
				func()
				debug.resetmemorycategory()
			end
		else
			return func
		end
	end
	local function reuseThread(func)
		if inactiveThread then
			task.spawn(inactiveThread, func)
		else
			task.spawn(reusableThread, func)
		end
	end
	--[[
		*
		     * Explicitly include an optional class in the startup cycle.
		     
	]]
	local function includeOptionalClass(ctor)
		Reflect.defineMetadata(ctor, "flamework:optional", false)
	end
	_container.includeOptionalClass = includeOptionalClass
	--[[
		*
		     * Initialize Flamework.
		     *
		     * This will start up the lifecycle events on all currently registered
		     * classes.
		     *
		     * You should preload all necessary directories before calling this
		     * as newly registered classes will not run their lifecycle events.
		     
	]]
	local function ignite()
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		for _, ctor in Reflect.idToObj do
			if not isConstructor(ctor) then
				continue
			end
			if not Reflect.getMetadata(ctor, "flamework:singleton") then
				continue
			end
			if Reflect.getMetadata(ctor, "flamework:optional") then
				continue
			end
			Modding.resolveSingleton(ctor)
			logIfVerbose(`Resolving singleton {ctor}`)
		end
		local dependencies = {}
		for ctor, dependency in Modding.getSingletons() do
			local _condition = Reflect.getMetadata(ctor, "flamework:loadOrder")
			if _condition == nil then
				_condition = 1
			end
			local loadOrder = _condition
			local _arg0 = { dependency, loadOrder }
			table.insert(dependencies, _arg0)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#dependencies)
		local _callback = function(_param)
			local obj = _param[1]
			return getIdentifier(obj)
		end
		for _k, _v in dependencies do
			_newValue[_k] = _callback(_v, _k - 1, dependencies)
		end
		-- ▲ ReadonlyArray.map ▲
		local sortedDependencies = topologicalSort(_newValue)
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		table.sort(dependencies, function(_param, _param_1)
			local depA = _param[1]
			local aOrder = _param[2]
			local depB = _param_1[1]
			local bOrder = _param_1[2]
			if aOrder ~= bOrder then
				return aOrder < bOrder
			end
			local _arg0 = getIdentifier(depA)
			local aIndex = sortedDependencies[_arg0]
			local _arg0_1 = getIdentifier(depB)
			local bIndex = sortedDependencies[_arg0_1]
			return aIndex < bIndex
		end)
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnTick")
			tick[_object] = _arg1
			return tick
		end, "$:flamework@OnTick")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnPhysics")
			physics[_object] = _arg1
			return physics
		end, "$:flamework@OnPhysics")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnRender")
			render[_object] = _arg1
			return render
		end, "$:flamework@OnRender")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = tick[_object] ~= nil
			tick[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnTick")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = physics[_object] ~= nil
			physics[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnPhysics")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = render[_object] ~= nil
			render[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnRender")
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg0 = { dependency, getIdentifier(dependency) }
				table.insert(init, _arg0)
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg0 = { dependency, getIdentifier(dependency) }
				table.insert(start, _arg0)
			end
		end
		for _, _binding in init do
			local dependency = _binding[1]
			local identifier = _binding[2]
			if isProfiling then
				debug.setmemorycategory(identifier)
			end
			logIfVerbose(`OnInit {identifier}`)
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error(`OnInit failed for dependency '{identifier}'. {tostring(value)}`)
				end
			end
		end
		debug.resetmemorycategory()
		RunService.Heartbeat:Connect(function(dt)
			for dependency, identifier in tick do
				reuseThread(profileYielding(function()
					return dependency:onTick(dt)
				end, identifier))
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for dependency, identifier in physics do
				reuseThread(profileYielding(function()
					return dependency:onPhysics(dt, time)
				end, identifier))
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for dependency, identifier in render do
					reuseThread(profileYielding(function()
						return dependency:onRender(dt)
					end, identifier))
				end
			end)
		end
		for _, _binding in start do
			local dependency = _binding[1]
			local identifier = _binding[2]
			logIfVerbose(`OnStart {identifier}`)
			reuseThread(profileYielding(function()
				return dependency:onStart()
			end, identifier))
		end
	end
	_container.ignite = ignite
	--[[
		*
		     * Preload the specified paths by requiring all ModuleScript descendants.
		     *
		     * @metadata macro intrinsic-arg-shift {@link _addPaths intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Preload the specified paths by requiring all ModuleScript descendants.
		     *
		     * This function supports globs allowing you to match files or directories based on patterns,
		     * but it should be noted that this can generate really large lists of paths and it is recommended to capture as few matches as possible.
		     *
		     * @metadata macro intrinsic-arg-shift {@link _addPathsGlob intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Retrieve the identifier for the specified type.
		     *
		     * @metadata macro {@link id intrinsic-inline}
		     
	]]
	--[[
		*
		     * Check if the constructor implements the specified interface.
		     *
		     * @metadata macro {@link _implements intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Check if object implements the specified interface.
		     *
		     * @metadata macro {@link _implements intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Hash a function using the method used internally by Flamework.
		     * If a context is provided, then Flamework will create a new hash
		     * if the specified string does not have one in that context.
		     * @param str The string to hash
		     * @param context A scope for the hash
		     * @metadata macro {@link meta intrinsic-inline}
		     
	]]
	--[[
		*
		     * Creates a type guard from any arbitrary type.
		     *
		     * @metadata macro
		     
	]]
	local function createGuard(meta)
		return meta
	end
	_container.createGuard = createGuard
end
--[[
	*
	 * An internal class used for resolving the Dependency<T> macro.
	 
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	 * This function resolves a dependency and can be called outside of the usual dependency injection lifecycle.
	 *
	 * This function can make it harder to stub, test or modify your code so it is recommended to use this macro minimally.
	 * It is recommended that you pass dependencies to code that needs it from a singleton, component, etc.
	 *
	 * @metadata macro {@link Flamework.resolveDependency intrinsic-flamework-rewrite}
	 
]]
--[[
	*
	 * Register a class as a Service.
	 *
	 * @server
	 * @metadata flamework:implements flamework:parameters injectable
	 
]]
local Service = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsServer() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		Reflect.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	 * Register a class as a Controller.
	 *
	 * @client
	 * @metadata flamework:implements flamework:parameters injectable
	 
]]
local Controller = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsClient() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		Reflect.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	 * Marks a singleton as optional.
	 *
	 * This singleton will only be included if it is depended on or is explicitly included with `Flamework.includeOptionalClass`.
	 
]]
local Optional = Modding.createDecorator("Class", function(descriptor)
	if not Reflect.getMetadata(descriptor.object, "flamework:singleton") then
		warn("'Optional' decorator was applied to a non-singleton.", descriptor.object)
		warn("Make sure you apply the 'Optional' decorator above other decorators.")
	end
	Reflect.defineMetadata(descriptor.object, `flamework:optional`, true)
end)
--[[
	*
	 * Hook into the OnInit lifecycle event.
	 
]]
--[[
	*
	 * Hook into the OnStart lifecycle event.
	 
]]
--[[
	*
	 * Hook into the OnTick lifecycle event.
	 * Equivalent to: RunService.Heartbeat
	 
]]
--[[
	*
	 * Hook into the OnPhysics lifecycle event.
	 * Equivalent to: RunService.Stepped
	 
]]
--[[
	*
	 * Hook into the OnRender lifecycle event.
	 * Equivalent to: RunService.RenderStepped
	 *
	 * @client
	 
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	Optional = Optional,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="23">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">metadata</string>
									<string name="ScriptGuid">{08b84c91-a216-489b-8c4a-3821b3aac9c6}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	 * Metadata exposed by the Flamework transformer.
	 
]]
local Metadata = {}
do
	local _container = Metadata
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	local function getContainer(name)
		local current = script
		while current do
			local flamework = current:FindFirstChild("flamework")
			if flamework then
				local metadata = flamework:FindFirstChild(name)
				if metadata then
					return require(metadata)
				end
			end
			current = current.Parent
		end
	end
	local configContainer
	local function getConfig(packageId)
		local _result
		if packageId == nil then
			local _result_1 = configContainer
			if _result_1 ~= nil then
				_result_1 = _result_1.game
			end
			_result = _result_1
		else
			local _result_1 = configContainer
			if _result_1 ~= nil then
				local _packages = _result_1.packages
				local _packageId = packageId
				_result_1 = _packages[_packageId]
			end
			_result = _result_1
		end
		return _result
	end
	configContainer = getContainer("config")
	_container.configContainer = configContainer
	local globContainer = getContainer("globs")
	_container.globContainer = globContainer
	local _result = configContainer
	if _result ~= nil then
		_result = _result.game
	end
	local _condition = _result
	if _condition == nil then
		_condition = {}
	end
	local gameConfig = _condition
	_container.gameConfig = gameConfig
	local function getGlob(glob, packageId)
		local _result_1
		if packageId == nil then
			local _result_2 = globContainer
			if _result_2 ~= nil then
				_result_2 = _result_2.game
			end
			_result_1 = _result_2
		else
			local _result_2 = globContainer
			if _result_2 ~= nil then
				local _packages = _result_2.packages
				local _packageId = packageId
				_result_2 = _packages[_packageId]
			end
			_result_1 = _result_2
		end
		local globs = _result_1
		local _result_2 = globs
		if _result_2 ~= nil then
			local _glob = glob
			_result_2 = _result_2[_glob]
		end
		return _result_2
	end
	_container.getGlob = getGlob
	local function getLogLevel(packageId)
		local config = getConfig(packageId)
		if not config or config.logLevel == nil then
			return "none"
		end
		return config.logLevel
	end
	_container.getLogLevel = getLogLevel
	local function isProfiling(packageId)
		local config = getConfig(packageId)
		if not config or config.profiling == nil then
			return RunService:IsStudio()
		end
		return config.profiling
	end
	_container.isProfiling = isProfiling
end
return {
	Metadata = Metadata,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000039f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="24">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">modding</string>
									<string name="ScriptGuid">{f0ba55bf-f2b7-440b-816f-ef1b3f4547d4}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
local getDeferredConstructor
local Modding = {}
do
	local _container = Modding
	local listeners = {}
	local lifecycleListeners = {}
	local decoratorListeners = {}
	local listenerAdded = Signal.new()
	local listenerRemoved = Signal.new()
	local listenerAddedEvents = {}
	local listenerRemovedEvents = {}
	local dependencyResolution = {}
	local resolvedSingletons = {}
	local loadingList = {}
	--[[
		*
		     * Retrieves an object from its identifier.
		     *
		     * The reverse (getting an identifier from an object) can be achieved using the Reflect API directly.
		     
	]]
	local function getObjectFromId(id)
		local _idToObj = Reflect.idToObj
		local _id = id
		return _idToObj[_id]
	end
	_container.getObjectFromId = getObjectFromId
	--[[
		*
		     * Registers a listener for lifecycle events.
		     
	]]
	local function addListener(object)
		local listener = {
			eventIds = {},
			involvement = {},
		}
		for _, lifecycleEvents in Reflect.getMetadatas(object, `flamework:implements`) do
			for _1, lifecycleEvent in lifecycleEvents do
				if listener.eventIds[lifecycleEvent] ~= nil then
					continue
				end
				local lifecycleListener = lifecycleListeners[lifecycleEvent]
				if not lifecycleListener then
					lifecycleListener = {}
					local _lifecycleListener = lifecycleListener
					lifecycleListeners[lifecycleEvent] = _lifecycleListener
				end
				local _lifecycleListener = lifecycleListener
				local _object = object
				_lifecycleListener[_object] = true
				listener.eventIds[lifecycleEvent] = true
				local _involvement = listener.involvement
				local _lifecycleListener_1 = lifecycleListener
				table.insert(_involvement, _lifecycleListener_1)
				local _result = listenerAddedEvents[lifecycleEvent]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local decorators = Reflect.getMetadata(object, `flamework:decorators`)
		if decorators then
			for _, decorator in decorators do
				if listener.eventIds[decorator] ~= nil then
					continue
				end
				local decoratorListener = decoratorListeners[decorator]
				if not decoratorListener then
					decoratorListener = {}
					local _decoratorListener = decoratorListener
					decoratorListeners[decorator] = _decoratorListener
				end
				local _decoratorListener = decoratorListener
				local _object = object
				_decoratorListener[_object] = true
				listener.eventIds[decorator] = true
				local _involvement = listener.involvement
				local _decoratorListener_1 = decoratorListener
				table.insert(_involvement, _decoratorListener_1)
				local _result = listenerAddedEvents[decorator]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local _object = object
		listeners[_object] = listener
		listenerAdded:Fire(object)
	end
	_container.addListener = addListener
	--[[
		*
		     * Removes a listener for lifecycle events and decorators.
		     
	]]
	local function removeListener(object)
		local _object = object
		local listener = listeners[_object]
		if not listener then
			return nil
		end
		for _, set in listener.involvement do
			local _object_1 = object
			set[_object_1] = nil
		end
		for id in listener.eventIds do
			local _result = listenerRemovedEvents[id]
			if _result ~= nil then
				_result:Fire(object)
			end
		end
		local _object_1 = object
		listeners[_object_1] = nil
		listenerRemoved:Fire(object)
	end
	_container.removeListener = removeListener
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever any listener is added.
		     *
		     * Fires for all existing listeners.
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever a listener has a decorator with the specified ID.
		     *
		     * Fires for all existing listeners.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever a listener has a lifecycle event with the specified ID.
		     *
		     * Fires for all existing listeners.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     
	]]
	local function onListenerAdded(func, id)
		if id ~= nil then
			local _id = id
			local listenerAddedEvent = listenerAddedEvents[_id]
			if not listenerAddedEvent then
				local _exp = id
				listenerAddedEvent = Signal.new()
				local _listenerAddedEvent = listenerAddedEvent
				listenerAddedEvents[_exp] = _listenerAddedEvent
			end
			local _id_1 = id
			local _condition = lifecycleListeners[_id_1]
			if not _condition then
				local _id_2 = id
				_condition = decoratorListeners[_id_2]
			end
			local existingListeners = _condition
			if existingListeners then
				for listener in existingListeners do
					task.spawn(func, listener)
				end
			end
			return listenerAddedEvent:Connect(func)
		else
			for listener in listeners do
				task.spawn(func, listener)
			end
			return listenerAdded:Connect(func)
		end
	end
	_container.onListenerAdded = onListenerAdded
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever any listener is removed.
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever a listener has a decorator with the specified ID.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever a listener has a lifecycle event with the specified ID.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     
	]]
	local function onListenerRemoved(func, id)
		if id ~= nil then
			local _id = id
			local listenerRemovedEvent = listenerRemovedEvents[_id]
			if not listenerRemovedEvent then
				local _exp = id
				listenerRemovedEvent = Signal.new()
				local _listenerRemovedEvent = listenerRemovedEvent
				listenerRemovedEvents[_exp] = _listenerRemovedEvent
			end
			return listenerRemovedEvent:Connect(func)
		else
			return listenerRemoved:Connect(func)
		end
	end
	_container.onListenerRemoved = onListenerRemoved
	--[[
		*
		     * Registers a class decorator.
		     
	]]
	--[[
		*
		     * Registers a method decorator.
		     
	]]
	--[[
		*
		     * Registers a property decorator.
		     
	]]
	--[[
		*
		     * Registers a decorator.
		     
	]]
	local defineDecoratorMetadata
	local function createDecorator(_kind, func)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
				func(descriptor, config)
			end,
		}
	end
	_container.createDecorator = createDecorator
	--[[
		*
		     * Registers a metadata class decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata method decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata property decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata decorator.
		     
	]]
	local function createMetaDecorator(_kind)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
			end,
		}
	end
	_container.createMetaDecorator = createMetaDecorator
	--[[
		*
		     * Retrieves registered decorators.
		     *
		     * @metadata macro
		     
	]]
	local function getDecorators(id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _decorators = Reflect.decorators
		local _id = id
		local decorators = _decorators[_id]
		if not decorators then
			return {}
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#decorators)
		local _callback = function(object)
			local decoratorConfig = Reflect.getOwnMetadata(object, `flamework:decorators.{id}`)
			assert(decoratorConfig)
			return {
				object = object,
				constructor = if isConstructor(object) then object else nil,
				arguments = decoratorConfig.arguments,
			}
		end
		for _k, _v in decorators do
			_newValue[_k] = _callback(_v, _k - 1, decorators)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	_container.getDecorators = getDecorators
	--[[
		*
		     * Creates a map of every property using the specified decorator.
		     *
		     * @metadata macro
		     
	]]
	local getDecorator
	local function getPropertyDecorators(obj, id)
		local decorators = {}
		local _arg0 = id ~= nil
		assert(_arg0)
		for _, prop in Reflect.getProperties(obj) do
			local decorator = getDecorator(obj, prop, id)
			if decorator then
				decorators[prop] = decorator
			end
		end
		return decorators
	end
	_container.getPropertyDecorators = getPropertyDecorators
	--[[
		*
		     * Retrieves a decorator from an object or its properties.
		     *
		     * @metadata macro
		     
	]]
	function getDecorator(object, property, id)
		local decorator = Reflect.getMetadata(object, `flamework:decorators.{id}`, property)
		if not decorator then
			return nil
		end
		return decorator
	end
	_container.getDecorator = getDecorator
	--[[
		*
		     * Retrieves a singleton or instantiates one if it does not exist.
		     
	]]
	local createDependency
	local function resolveSingleton(ctor)
		local _ctor = ctor
		local resolvedDependency = resolvedSingletons[_ctor]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _ctor_1 = ctor
		if table.find(loadingList, _ctor_1) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _result = table.create(#loadingList)
			for _k, _v in loadingList do
				_result[_k] = tostring(_v)
			end
			-- ▲ ReadonlyArray.join ▲
			error(`Circular dependency detected {table.concat(_result, " <=> ")} <=> {ctor}`)
		end
		local _ctor_2 = ctor
		table.insert(loadingList, _ctor_2)
		-- Flamework can resolve singletons at any arbitrary point,
		-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.
		local opts = Reflect.getOwnMetadata(ctor, "flamework:dependency_resolution")
		local dependency = createDependency(ctor, opts)
		local _ctor_3 = ctor
		resolvedSingletons[_ctor_3] = dependency
		loadingList[#loadingList] = nil
		addListener(dependency)
		return dependency
	end
	_container.resolveSingleton = resolveSingleton
	--* @internal Used for bootstrapping 
	local function getSingletons()
		return resolvedSingletons
	end
	_container.getSingletons = getSingletons
	--[[
		*
		     * Modifies dependency resolution for a specific ID.
		     *
		     * If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.
		     * Otherwise, the passed object is returned directly.
		     *
		     * @metadata macro
		     
	]]
	local function registerDependency(dependency, id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _dependency = dependency
		if type(_dependency) == "function" then
			local _id = id
			local _dependency_1 = dependency
			dependencyResolution[_id] = _dependency_1
		else
			local _id = id
			dependencyResolution[_id] = function()
				return dependency
			end
		end
	end
	_container.registerDependency = registerDependency
	--[[
		*
		     * Instantiates this class using dependency injection.
		     
	]]
	local createDeferredDependency
	function createDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = createDeferredDependency(ctor, options)
		local obj = _binding[1]
		local construct = _binding[2]
		construct()
		return obj
	end
	_container.createDependency = createDependency
	--[[
		*
		     * Creates an object for this class and returns a deferred constructor.
		     
	]]
	local resolveDependency
	function createDeferredDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = getDeferredConstructor(ctor)
		local obj = _binding[1]
		local construct = _binding[2]
		return { obj, function()
			local dependencies = Reflect.getMetadata(ctor, "flamework:parameters")
			local constructorDependencies = {}
			if dependencies then
				for index, dependencyId in pairs(dependencies) do
					constructorDependencies[index] = resolveDependency(ctor, dependencyId, index - 1, options)
				end
			end
			construct(unpack(constructorDependencies))
		end }
	end
	_container.createDeferredDependency = createDeferredDependency
	--[[
		*
		     * Dependency resolution logic.
		     * @internal
		     
	]]
	function resolveDependency(ctor, dependencyId, index, options)
		if options.handle ~= nil then
			local dependency = options.handle(dependencyId, index)
			if dependency ~= nil then
				return dependency
			end
		end
		local _dependencyId = dependencyId
		local resolution = dependencyResolution[_dependencyId]
		if resolution ~= nil then
			return resolution(ctor)
		end
		local _idToObj = Reflect.idToObj
		local _dependencyId_1 = dependencyId
		local dependencyCtor = _idToObj[_dependencyId_1]
		if dependencyCtor and isConstructor(dependencyCtor) then
			return resolveSingleton(dependencyCtor)
		end
		if string.sub(dependencyId, 1, 2) == "$p" then
			if string.sub(dependencyId, 1, 3) == "$ps" then
				return string.sub(dependencyId, 5)
			end
			if string.sub(dependencyId, 1, 3) == "$pn" then
				local _condition = tonumber(string.sub(dependencyId, 5))
				if _condition == nil then
					_condition = 0
				end
				return _condition
			end
			if options.handlePrimitive ~= nil then
				return options.handlePrimitive(dependencyId, index)
			end
			error(`Unexpected primitive dependency '{dependencyId}' while constructing {ctor}`)
		end
		error(`Could not find constructor for {dependencyId} while constructing {ctor}`)
	end
	_container.resolveDependency = resolveDependency
	--[[
		*
		     * This function is able to utilize Flamework's user macros to generate and inspect types.
		     * This function supports all values natively supported by Flamework's user macros.
		     *
		     * For example, if you want to retrieve the properties of an instance, you could write code like this:
		     * ```ts
		     * // Returns an array of all keys part of the union.
		     * const basePartKeys = Modding.inspect<InstancePropertyNames<BasePart>[]>();
		     * ```
		     *
		     * @metadata macro
		     
	]]
	local function inspect(value)
		local _value = value
		assert(_value)
		return value
	end
	_container.inspect = inspect
	--[[
		*
		     * This API allows you to use more complex queries, inspect types, generate arbitrary objects based on types, etc.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Hashes a string literal type (such as an event name) under Flamework's {@link Many `Many`} API.
		     *
		     * The second type argument, `C`, is for providing a context to the hashing which will generate new hashes
		     * for strings which already have a hash under another context.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * This is equivalent to {@link Hash `Hash`} except it will only hash strings when `obfuscation` is turned on.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Retrieves the labels from this tuple under Flamework's {@link Many `Many`} API.
		     *
		     * This can also be used to extract parameter names via `Parameters<T>`
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Retrieves metadata about the specified type using Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves multiple types of metadata from Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves metadata about the callsite using Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves multiple types of metadata about the callsite using Flamework's user macros.
		     
	]]
	--[[
		*
		     * An internal type for intrinsic user macro metadata.
		     *
		     * @hidden
		     
	]]
	function defineDecoratorMetadata(descriptor, config)
		local propertyKey = if descriptor.isStatic then `static:{descriptor.property}` else descriptor.property
		Reflect.defineMetadata(descriptor.object, `flamework:decorators.{descriptor.id}`, {
			arguments = config,
		}, propertyKey)
		local decoratorList = Reflect.getMetadata(descriptor.object, `flamework:decorators`, propertyKey)
		if not decoratorList then
			local _exp = descriptor.object
			decoratorList = {}
			Reflect.defineMetadata(_exp, "flamework:decorators", decoratorList, propertyKey)
		end
		local _decoratorList = decoratorList
		local _id = descriptor.id
		table.insert(_decoratorList, _id)
	end
end
function getDeferredConstructor(ctor)
	local obj = setmetatable({}, ctor)
	return { obj, function(...)
		local args = { ... }
		local result = obj:constructor(unpack(args))
		local _arg0 = result == nil or result == obj
		local _arg1 = `Deferred constructors are not allowed to return values.`
		assert(_arg0, _arg1)
	end }
end
return {
	Modding = Modding,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="25">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">prelude</string>
									<string name="ScriptGuid">{2d9fcd8f-70af-45e2-871a-acc8579fd4c8}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * This file contains preludes for the transformer.
	 *
	 * This is primarily necessary due to a bug with the `@rbxts/t` package.
	 
]]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
return {
	t = t,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="26">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">reflect</string>
									<string name="ScriptGuid">{8ee6f6f1-a6a8-41bd-a515-a84f937a146d}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
--[[
	*
	 * Reflection/metadata API
	 
]]
local Reflect = {}
do
	local _container = Reflect
	--* object -> property -> key -> value 
	local metadata = setmetatable({}, {
		__mode = "k",
	})
	local objToId = {}
	--* @internal 
	local decorators = {}
	_container.decorators = decorators
	--* @internal 
	local idToObj = {}
	_container.idToObj = idToObj
	local NO_PROP_MARKER = {}
	local function getObjMetadata(obj, prop, create)
		local _condition = prop
		if _condition == nil then
			_condition = NO_PROP_MARKER
		end
		local realProp = _condition
		if create then
			local _obj = obj
			local objMetadata = metadata[_obj]
			if not objMetadata then
				local _exp = obj
				objMetadata = {}
				local _objMetadata = objMetadata
				metadata[_exp] = _objMetadata
			end
			local propMetadata = objMetadata[realProp]
			if not propMetadata then
				local _objMetadata = objMetadata
				propMetadata = {}
				local _propMetadata = propMetadata
				_objMetadata[realProp] = _propMetadata
			end
			return propMetadata
		else
			local _obj = obj
			local _result = metadata[_obj]
			if _result ~= nil then
				_result = _result[realProp]
			end
			return _result
		end
	end
	local function getParentConstructor(obj)
		local metatable = getmetatable(obj)
		if metatable and type(metatable) == "table" then
			return rawget(metatable, "__index")
		end
	end
	--[[
		*
		     * Apply metadata onto this object.
		     
	]]
	local function defineMetadata(obj, key, value, property)
		-- 'identifier' is a special, unique ID across all metadata classes.
		if key == "identifier" then
			local _value = value
			local _arg0 = type(_value) == "string"
			assert(_arg0, "identifier must be a string.")
			local _obj = obj
			local _arg0_1 = not (objToId[_obj] ~= nil)
			assert(_arg0_1, "obj is already registered.")
			local _value_1 = value
			local _arg0_2 = not (idToObj[_value_1] ~= nil)
			assert(_arg0_2, "id is already registered.")
			local _obj_1 = obj
			local _value_2 = value
			objToId[_obj_1] = _value_2
			local _value_3 = value
			local _obj_2 = obj
			idToObj[_value_3] = _obj_2
		end
		local metadata = getObjMetadata(obj, property, true)
		local _key = key
		local _value = value
		metadata[_key] = _value
	end
	_container.defineMetadata = defineMetadata
	--[[
		*
		     * Apply metadata in batch onto this object.
		     
	]]
	local function defineMetadataBatch(obj, list, property)
		local metadata = getObjMetadata(obj, property, true)
		for key, value in pairs(list) do
			metadata[key] = value
		end
	end
	_container.defineMetadataBatch = defineMetadataBatch
	--[[
		*
		     * Delete metadata from this object.
		     
	]]
	local function deleteMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result[_key] = nil
		end
	end
	_container.deleteMetadata = deleteMetadata
	--[[
		*
		     * Get metadata from this object.
		     * Type parameter is an assertion.
		     
	]]
	local function getOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key]
		end
		return _result
	end
	_container.getOwnMetadata = getOwnMetadata
	--[[
		*
		     * Check if this object has the specified metadata key.
		     
	]]
	local function hasOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key] ~= nil
		end
		local _condition = _result
		if _condition == nil then
			_condition = false
		end
		return _condition
	end
	_container.hasOwnMetadata = hasOwnMetadata
	--[[
		*
		     * Retrieve all metadata keys for this object.
		     
	]]
	local function getOwnMetadataKeys(obj, property)
		local metadata = getObjMetadata(obj, property)
		local keys = {}
		local _result = metadata
		if _result ~= nil then
			-- ▼ ReadonlyMap.forEach ▼
			local _callback = function(_, key)
				local _key = key
				table.insert(keys, _key)
				return #keys
			end
			for _k, _v in _result do
				_callback(_v, _k, _result)
			end
			-- ▲ ReadonlyMap.forEach ▲
		end
		return keys
	end
	_container.getOwnMetadataKeys = getOwnMetadataKeys
	--[[
		*
		     * Retrieves all properties (that contain metadata) on this object.
		     
	]]
	local function getOwnProperties(obj)
		local _obj = obj
		local properties = metadata[_obj]
		if not properties then
			return {}
		end
		local keys = {}
		for key in properties do
			if key ~= NO_PROP_MARKER then
				table.insert(keys, key)
			end
		end
		return keys
	end
	_container.getOwnProperties = getOwnProperties
	--[[
		*
		     * Retrieve all values for the specified key from the object and its parents.
		     * Type parameter is an assertion.
		     
	]]
	local function getMetadatas(obj, key, property)
		local values = {}
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			table.insert(values, value)
		end
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadatas(parent, key, property)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(value)
				local _value = value
				table.insert(values, _value)
				return #values
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		return values
	end
	_container.getMetadatas = getMetadatas
	--[[
		*
		     * Get metadata from this object or its parents.
		     * Type parameter is an assertion.
		     
	]]
	local function getMetadata(obj, key, property)
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return getMetadata(parent, key, property)
		end
	end
	_container.getMetadata = getMetadata
	--[[
		*
		     * Check if this object or any of its parents has the specified metadata key.
		     
	]]
	local function hasMetadata(obj, key, property)
		local value = hasOwnMetadata(obj, key, property)
		if value then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return hasMetadata(parent, key, property)
		end
		return false
	end
	_container.hasMetadata = hasMetadata
	--[[
		*
		     * Retrieve all metadata keys for this object and its parents.
		     
	]]
	local function getMetadataKeys(obj, property)
		local _set = {}
		for _, _v in getOwnMetadataKeys(obj, property) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadataKeys(parent, property)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getMetadataKeys = getMetadataKeys
	--[[
		*
		     * Retrieves all properties (that contain metadata) on this object and its parents.
		     
	]]
	local function getProperties(obj)
		local _set = {}
		for _, _v in getOwnProperties(obj) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getProperties(parent)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getProperties = getProperties
	--* @hidden 
	local function decorate(object, id, rawDecoration, args, property, isStatic)
		if isStatic == nil then
			isStatic = false
		end
		local decoration = rawDecoration
		local descriptor = {
			id = id,
			isStatic = isStatic,
			object = object,
			constructor = if isConstructor(object) then object else nil,
			property = property,
		}
		if property == nil then
			local _id = id
			local decoratedObjects = decorators[_id]
			if not decoratedObjects then
				local _exp = id
				decoratedObjects = {}
				local _decoratedObjects = decoratedObjects
				decorators[_exp] = _decoratedObjects
			end
			local _decoratedObjects = decoratedObjects
			local _object = object
			table.insert(_decoratedObjects, _object)
		end
		decoration.func(descriptor, args)
	end
	_container.decorate = decorate
	--* @hidden Internal use, do not use 
	local function resetObject(object)
		local _object = object
		local id = objToId[_object]
		if id ~= nil then
			local _object_1 = object
			objToId[_object_1] = nil
			idToObj[id] = nil
		end
		local _object_1 = object
		metadata[_object_1] = nil
	end
	_container.resetObject = resetObject
end
return {
	Reflect = Reflect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a2</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="27">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">utility</string>
									<string name="ScriptGuid">{b8518ebe-f721-4642-b8ec-fd2da26cda8a}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--* @hidden 
local isAbstractConstructor
local function isConstructor(obj)
	return isAbstractConstructor(obj) and obj.new ~= nil
end
function isAbstractConstructor(obj)
	return obj.constructor ~= nil
end
return {
	isConstructor = isConstructor,
	isAbstractConstructor = isAbstractConstructor,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a3</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="28">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">networking</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a4</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{4e7e6712-3bfc-4f4c-bd3d-b285242b80d8}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local NetworkingSkip = TS.import(script, script, "middleware", "skip").Skip
local NetworkingFunctionError = TS.import(script, script, "function", "errors").NetworkingFunctionError
local createNetworkingEvent = TS.import(script, script, "events", "createNetworkingEvent").createNetworkingEvent
local createNetworkingFunction = TS.import(script, script, "functions", "createNetworkingFunction").createNetworkingFunction
local Networking = {}
do
	local _container = Networking
	--[[
		*
		     * Creates a new event based off the supplied types.
		     * @param serverMiddleware Middleware for server events
		     * @param clientMiddleware Middleware for client events
		     * @metadata macro
		     
	]]
	local function createEvent(name)
		return createNetworkingEvent(name)
	end
	_container.createEvent = createEvent
	--[[
		*
		     * Creates a new function event based off the supplied types.
		     * @param serverMiddleware Middleware for server events
		     * @param clientMiddleware Middleware for client events
		     * @metadata macro
		     
	]]
	local function createFunction(name)
		return createNetworkingFunction(name)
	end
	_container.createFunction = createFunction
	--[[
		*
		     * Stops networking function middleware.
		     
	]]
	local Skip = NetworkingSkip
	_container.Skip = Skip
	--[[
		*
		     * Specifies that this event is unreliable.
		     *
		     * This will only work on remote events.
		     
	]]
	--[[
		*
		     * A function that generates an event middleware.
		     
	]]
	--[[
		*
		     * A function that generates an event middleware.
		     
	]]
end
return {
	Networking = Networking,
	NetworkingFunctionError = NetworkingFunctionError,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a5</UniqueId>
							</Properties>
							<Item class="Folder" referent="30">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">event</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a6</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="31">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createEvent</string>
										<string name="ScriptGuid">{77a948fe-9343-4db0-bf91-cc925906cbb7}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local createRemoteInstance = TS.import(script, script.Parent, "createRemoteInstance").createRemoteInstance
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local function createEvent(options)
	local remote = createRemoteInstance(if options.reliability == "unreliable" then "UnreliableRemoteEvent" else "RemoteEvent", options.namespace, options.debugName, options.id)
	local bindable
	local invoke = createMiddlewareProcessor(options.incomingMiddleware, options.networkInfo, function(player, ...)
		local args = { ... }
		if RunService:IsServer() then
			bindable:Fire(player, unpack(args))
		else
			bindable:Fire(unpack(args))
		end
	end)
	local createConnection = function(callback)
		if bindable then
			return bindable.Event:Connect(callback)
		end
		bindable = Instance.new("BindableEvent")
		-- We defer to allow any other immediate connections to take place before unloading Roblox's queue.
		task.defer(function()
			if RunService:IsServer() then
				remote.OnServerEvent:Connect(function(player, ...)
					local args = { ... }
					invoke(player, unpack(args))
				end)
			else
				remote.OnClientEvent:Connect(function(...)
					local args = { ... }
					invoke(nil, unpack(args))
				end)
			end
		end)
		return bindable.Event:Connect(callback)
	end
	return {
		fireEither = function(self, player, ...)
			local args = { ... }
			if player then
				self:fireClient(player, unpack(args))
			else
				self:fireServer(unpack(args))
			end
		end,
		fireServer = function(self, ...)
			local args = { ... }
			remote:FireServer(unpack(args))
		end,
		fireClient = function(self, player, ...)
			local args = { ... }
			remote:FireClient(player, unpack(args))
		end,
		fireAllClients = function(self, ...)
			local args = { ... }
			remote:FireAllClients(unpack(args))
		end,
		connectServer = function(self, callback)
			local _arg0 = RunService:IsServer()
			assert(_arg0)
			return createConnection(callback)
		end,
		connectClient = function(self, callback)
			local _arg0 = RunService:IsClient()
			assert(_arg0)
			return createConnection(callback)
		end,
		invoke = invoke,
	}
end
return {
	createEvent = createEvent,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="32">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createRemoteInstance</string>
										<string name="ScriptGuid">{d938ed2e-ca26-4b6d-a959-67ac14e440c7}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local function findByAttribute(parent, id)
	for _, child in parent:GetChildren() do
		if child:GetAttribute("id") == id then
			return child
		end
	end
end
local function waitByAttribute(parent, id)
	local instance = findByAttribute(parent, id)
	local watcherThread = task.delay(5, function()
		warn(`Flamework is waiting on '{id}' for`, parent)
	end)
	if not instance then
		local thread = coroutine.running()
		local connection
		connection = parent.ChildAdded:Connect(function(instance)
			if instance:GetAttribute("id") == id then
				connection:Disconnect()
				task.spawn(thread, instance)
			end
		end)
		instance = (coroutine.yield())
	end
	task.cancel(watcherThread)
	return instance
end
local function createRemoteInstance(remoteType, namespace, debugName, id)
	if not RunService:IsRunning() then
		return Instance.new(remoteType)
	end
	local namespaceFolder = if RunService:IsServer() then findByAttribute(ReplicatedStorage, namespace) else waitByAttribute(ReplicatedStorage, namespace)
	if not namespaceFolder then
		namespaceFolder = Instance.new("Folder")
		namespaceFolder.Name = namespace
		namespaceFolder:SetAttribute("id", namespace)
		namespaceFolder.Parent = ReplicatedStorage
	end
	local existingInstance = if RunService:IsServer() then findByAttribute(namespaceFolder, id) else waitByAttribute(namespaceFolder, id)
	if not existingInstance then
		existingInstance = Instance.new(remoteType)
		existingInstance.Name = debugName
		existingInstance:SetAttribute("id", id)
		existingInstance.Parent = namespaceFolder
	end
	local _arg0 = existingInstance:IsA(remoteType)
	assert(_arg0)
	return existingInstance
end
return {
	createRemoteInstance = createRemoteInstance,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a8</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="33">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">events</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003a9</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="34">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createClientMethod</string>
										<string name="ScriptGuid">{91322418-1d40-4138-8eba-66b48586514b}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local function createClientMethod(receiver, sender)
	local method = {
		fire = function(self, ...)
			local args = { ... }
			sender:fireServer(unpack(args))
		end,
		connect = function(self, callback)
			return receiver:connectClient(callback)
		end,
		predict = function(self, ...)
			local args = { ... }
			return receiver.invoke(nil, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			method:fire(unpack(args))
		end,
	})
	return method
end
return {
	createClientMethod = createClientMethod,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003aa</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="35">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createGenericHandler</string>
										<string name="ScriptGuid">{87663625-82ab-4c4e-9726-7cfc3a828465}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local createGuardMiddleware = TS.import(script, script.Parent.Parent, "middleware", "createGuardMiddleware").createGuardMiddleware
local createEvent = TS.import(script, script.Parent.Parent, "event", "createEvent").createEvent
local getNamespaceConfig = TS.import(script, script.Parent.Parent, "util", "getNamespaceConfig").getNamespaceConfig
local function createGenericHandler(globalName, namespaceName, metadata, config, signals, method)
	local handler = {}
	local _set = {}
	for _, _v in metadata.incomingIds do
		_set[_v] = true
	end
	local receiverNameSet = _set
	local _set_1 = {}
	for _, _v in metadata.outgoingIds do
		_set_1[_v] = true
	end
	local senderNameSet = _set_1
	local _set_2 = {}
	local _array = {}
	local _length = #_array
	local _array_1 = metadata.incomingIds
	local _Length = #_array_1
	table.move(_array_1, 1, _Length, _length + 1, _array)
	_length += _Length
	local _array_2 = metadata.outgoingIds
	table.move(_array_2, 1, #_array_2, _length + 1, _array)
	for _, _v in _array do
		_set_2[_v] = true
	end
	for name in _set_2 do
		local isIncoming = receiverNameSet[name] ~= nil
		local isOutgoing = senderNameSet[name] ~= nil
		-- If there is no incoming/outgoing event, use the same reliability as the other.
		local incomingChannel = if isIncoming then metadata.incomingUnreliable else metadata.outgoingUnreliable
		local outgoingChannel = if isOutgoing then metadata.outgoingUnreliable else metadata.incomingUnreliable
		local isIncomingUnreliable = incomingChannel[name] == true
		local isOutgoingUnreliable = outgoingChannel[name] == true
		local configMiddleware = config.middleware[name]
		local incomingMiddleware = if configMiddleware ~= nil then table.clone(configMiddleware) else {}
		local effectiveName = if namespaceName ~= nil then `{namespaceName}/{name}` else name
		local networkInfo = {
			eventType = "Event",
			name = effectiveName,
			globalName = globalName,
		}
		if not config.disableIncomingGuards and isIncoming then
			local guards = metadata.incoming[name]
			assert(guards)
			local _arg0 = createGuardMiddleware(name, guards[1], guards[2], networkInfo, config.warnOnInvalidGuards, signals)
			table.insert(incomingMiddleware, 1, _arg0)
		end
		local create = function(unreliable)
			return createEvent({
				reliability = if unreliable then "unreliable" else "reliable",
				namespace = globalName,
				id = if unreliable then `unreliable:{effectiveName}` else effectiveName,
				debugName = name,
				networkInfo = networkInfo,
				incomingMiddleware = incomingMiddleware,
			})
		end
		local receiver = create(isIncomingUnreliable)
		local sender = if isOutgoingUnreliable == isIncomingUnreliable then receiver else create(isOutgoingUnreliable)
		handler[name] = method(receiver, sender)
	end
	for _, namespaceId in metadata.namespaceIds do
		local namespace = metadata.namespaces[namespaceId]
		handler[namespaceId] = createGenericHandler(globalName, if namespaceName ~= nil then `{namespaceName}/{namespaceId}` else namespaceId, namespace, getNamespaceConfig(config, namespaceId), signals, method)
	end
	return handler
end
return {
	createGenericHandler = createGenericHandler,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ab</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="36">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createNetworkingEvent</string>
										<string name="ScriptGuid">{4fe1e405-72d3-49b3-b4d2-4922551e0340}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local createClientMethod = TS.import(script, script.Parent, "createClientMethod").createClientMethod
local createServerMethod = TS.import(script, script.Parent, "createServerMethod").createServerMethod
local createSignalContainer = TS.import(script, script.Parent.Parent, "util", "createSignalContainer").createSignalContainer
local createGenericHandler = TS.import(script, script.Parent, "createGenericHandler").createGenericHandler
local function getDefaultConfiguration(config)
	local _object = {}
	local _left = "middleware"
	local _condition = config.middleware
	if _condition == nil then
		_condition = {}
	end
	_object[_left] = _condition
	local _left_1 = "warnOnInvalidGuards"
	local _condition_1 = config.warnOnInvalidGuards
	if _condition_1 == nil then
		_condition_1 = RunService:IsStudio()
	end
	_object[_left_1] = _condition_1
	local _left_2 = "disableIncomingGuards"
	local _condition_2 = config.disableIncomingGuards
	if _condition_2 == nil then
		_condition_2 = false
	end
	_object[_left_2] = _condition_2
	return _object
end
local function createNetworkingEvent(globalName)
	local signals = createSignalContainer()
	local server
	local client
	return {
		createServer = function(self, config, meta)
			if RunService:IsRunning() and not RunService:IsServer() then
				return nil
			end
			if server == nil then
				server = createGenericHandler(globalName, nil, meta, getDefaultConfiguration(config), signals, createServerMethod)
			end
			return server
		end,
		createClient = function(self, config, meta)
			if RunService:IsRunning() and not RunService:IsClient() then
				return nil
			end
			if client == nil then
				client = createGenericHandler(globalName, nil, meta, getDefaultConfiguration(config), signals, createClientMethod)
			end
			return client
		end,
		registerHandler = function(self, key, callback)
			return signals:connect(key, callback)
		end,
	}
end
return {
	createNetworkingEvent = createNetworkingEvent,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ac</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="37">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createServerMethod</string>
										<string name="ScriptGuid">{02e7a592-2474-4f30-af71-36868031bc2e}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local function createServerMethod(receiver, sender)
	local method = {
		fire = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				sender:fireClient(players, unpack(args))
			else
				for _, player in players do
					sender:fireClient(player, unpack(args))
				end
			end
		end,
		broadcast = function(self, ...)
			local args = { ... }
			sender:fireAllClients(unpack(args))
		end,
		except = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				players = { players }
			end
			for _, player in Players:GetPlayers() do
				if not (table.find(players, player) ~= nil) then
					self:fire(player, unpack(args))
				end
			end
		end,
		connect = function(self, callback)
			return receiver:connectServer(callback)
		end,
		predict = function(self, player, ...)
			local args = { ... }
			receiver.invoke(player, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			method:fire(player, unpack(args))
		end,
	})
	return method
end
return {
	createServerMethod = createServerMethod,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ad</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="38">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">function</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ae</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="39">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createFunctionReceiver</string>
										<string name="ScriptGuid">{0264d55f-414a-4270-8cfe-db887153c06c}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local createEvent = TS.import(script, script.Parent.Parent, "event", "createEvent").createEvent
local NetworkingFunctionError = TS.import(script, script.Parent, "errors").NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local _skip = TS.import(script, script.Parent.Parent, "middleware", "skip")
local Skip = _skip.Skip
local SkipBadRequest = _skip.SkipBadRequest
local getProcessResult
local function createFunctionReceiver(options)
	local event = createEvent({
		namespace = options.namespace,
		debugName = options.debugName,
		id = options.id,
		networkInfo = options.networkInfo,
	})
	local callback
	local setCallback = function(newCallback)
		callback = createMiddlewareProcessor(options.incomingMiddleware, options.networkInfo, function(player, ...)
			local args = { ... }
			if RunService:IsServer() then
				return newCallback(player, unpack(args))
			else
				return newCallback(unpack(args))
			end
		end)
	end
	local processRequest = function(player, id, ...)
		local args = { ... }
		if not callback then
			return event:fireEither(player, id, NetworkingFunctionError.Unprocessed)
		end
		callback(player, unpack(args)):andThen(function(value)
			return event:fireEither(player, id, getProcessResult(value), value)
		end):catch(function(reason)
			warn(`Failed to process request to '{options.debugName}'`)
			warn(reason)
			event:fireEither(player, id, false)
		end)
	end
	if RunService:IsServer() then
		event:connectServer(function(player, id, ...)
			local args = { ... }
			return processRequest(player, id, unpack(args))
		end)
	else
		event:connectClient(function(id, ...)
			local args = { ... }
			return processRequest(nil, id, unpack(args))
		end)
	end
	return {
		setServerCallback = function(self, callback)
			setCallback(callback)
		end,
		setClientCallback = function(self, callback)
			setCallback(callback)
		end,
		invoke = function(self, player, ...)
			local args = { ... }
			if not callback then
				return TS.Promise.reject(NetworkingFunctionError.Unprocessed)
			end
			return callback(player, unpack(args)):andThen(function(value)
				local processResult = getProcessResult(value)
				return if processResult == true then value else TS.Promise.reject(processResult)
			end)
		end,
	}
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled elseif value == SkipBadRequest then NetworkingFunctionError.BadRequest else true
end
return {
	createFunctionReceiver = createFunctionReceiver,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003af</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="40">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createFunctionSender</string>
										<string name="ScriptGuid">{f4a65a3e-6ec1-4419-bf4a-ddf4d4a6a0bb}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local createEvent = TS.import(script, script.Parent.Parent, "event", "createEvent").createEvent
local _errors = TS.import(script, script.Parent, "errors")
local NetworkingFunctionError = _errors.NetworkingFunctionError
local getFunctionError = _errors.getFunctionError
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local createRequestInfo
local function createFunctionSender(options)
	local event = createEvent({
		namespace = options.namespace,
		debugName = options.debugName,
		id = options.id,
		networkInfo = options.networkInfo,
	})
	local processResponse = function(requestInfo, id, processResult, result)
		if not t.number(id) then
			return nil
		end
		local _requests = requestInfo.requests
		local _id = id
		local request = _requests[_id]
		local _requests_1 = requestInfo.requests
		local _id_1 = id
		_requests_1[_id_1] = nil
		if request then
			request(result, getFunctionError(processResult))
		end
	end
	-- We don't need to defer here because we only accept responses to our explicit invocations.
	local requestInfoServer = {}
	local requestInfoClient = createRequestInfo()
	if RunService:IsServer() then
		event:connectServer(function(player, id, processResult, result)
			local _player = player
			local requestInfo = requestInfoServer[_player]
			if not requestInfo then
				return nil
			end
			processResponse(requestInfo, id, processResult, result)
		end)
		Players.PlayerRemoving:Connect(function(player)
			local _player = player
			local requestInfo = requestInfoServer[_player]
			local _player_1 = player
			requestInfoServer[_player_1] = nil
			if requestInfo then
				-- Cancel all existing requests from this player.
				for _, request in requestInfo.requests do
					request(nil, NetworkingFunctionError.Cancelled)
				end
			end
		end)
	else
		event:connectClient(function(id, processResult, result)
			processResponse(requestInfoClient, id, processResult, result)
		end)
	end
	local createInvocation = function(player, id, requestInfo)
		return TS.Promise.new(function(resolve, reject, onCancel)
			local _requests = requestInfo.requests
			local _id = id
			_requests[_id] = function(value, rejection)
				if rejection then
					return reject(rejection)
				end
				if options.responseMiddleware then
					options.responseMiddleware(player, value, resolve, reject)
				else
					resolve(value)
				end
			end
			onCancel(function()
				local _requests_1 = requestInfo.requests
				local _id_1 = id
				_requests_1[_id_1] = nil
			end)
		end)
	end
	return {
		invokeServer = function(self, ...)
			local args = { ... }
			local _original = requestInfoClient.nextId
			requestInfoClient.nextId += 1
			local id = _original
			event:fireServer(id, unpack(args))
			return createInvocation(nil, id, requestInfoClient)
		end,
		invokeClient = function(self, player, ...)
			local args = { ... }
			local _player = player
			local requestInfo = requestInfoServer[_player]
			if not requestInfo then
				local _exp = player
				requestInfo = createRequestInfo()
				local _requestInfo = requestInfo
				requestInfoServer[_exp] = _requestInfo
			end
			local _original = requestInfoClient.nextId
			requestInfoClient.nextId += 1
			local id = _original
			event:fireClient(player, id, unpack(args))
			return createInvocation(player, id, requestInfo)
		end,
	}
end
function createRequestInfo()
	return {
		nextId = 0,
		requests = {},
	}
end
return {
	createFunctionSender = createFunctionSender,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="41">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">errors</string>
										<string name="ScriptGuid">{08238df3-b95b-4de8-bade-10ea6365e1ec}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local t = TS.import(script, TS.getModule(script, "@flamework", "core").out.prelude).t
local Flamework = TS.import(script, TS.getModule(script, "@flamework", "core").out).Flamework
local isNetworkingFunctionError = Flamework.createGuard(t.literalList({ "Timeout", "Cancelled", "BadRequest", "Unprocessed", "InvalidResult" }))
local NetworkingFunctionError = {
	Timeout = "Timeout",
	Cancelled = "Cancelled",
	BadRequest = "BadRequest",
	Unprocessed = "Unprocessed",
	InvalidResult = "InvalidResult",
}
local function getFunctionError(value)
	local _value = value
	if type(_value) == "boolean" then
		return if value == false then NetworkingFunctionError.Unprocessed else nil
	elseif isNetworkingFunctionError(value) then
		return value
	end
end
return {
	getFunctionError = getFunctionError,
	NetworkingFunctionError = NetworkingFunctionError,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b1</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="42">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">functions</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b2</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="43">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createClientMethod</string>
										<string name="ScriptGuid">{f76e9026-a34a-44c3-9b99-111ceaacd592}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local NetworkingFunctionError = TS.import(script, script.Parent.Parent, "function", "errors").NetworkingFunctionError
local timeoutPromise = TS.import(script, script.Parent.Parent, "util", "timeoutPromise").timeoutPromise
local function createClientMethod(config, receiver, sender)
	local method = {
		invoke = function(self, ...)
			local args = { ... }
			return self:invokeWithTimeout(config.defaultTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, timeout, ...)
			local args = { ... }
			local _sender = sender
			assert(_sender, "This is not a sender remote.")
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), sender:invokeServer(unpack(args)) })
		end,
		setCallback = function(self, callback)
			local _receiver = receiver
			assert(_receiver, "This is not a receiver remote.")
			receiver:setClientCallback(callback)
		end,
		predict = function(self, ...)
			local args = { ... }
			local _receiver = receiver
			assert(_receiver, "This is not a receiver remote.")
			return receiver:invoke(nil, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			return method:invoke(unpack(args))
		end,
	})
	return method
end
return {
	createClientMethod = createClientMethod,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="44">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createGenericHandler</string>
										<string name="ScriptGuid">{60f7af15-d09e-4744-b492-ad47b20368fe}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local NetworkingFunctionError = TS.import(script, script.Parent.Parent, "function", "errors").NetworkingFunctionError
local SkipBadRequest = TS.import(script, script.Parent.Parent, "middleware", "skip").SkipBadRequest
local createFunctionReceiver = TS.import(script, script.Parent.Parent, "function", "createFunctionReceiver").createFunctionReceiver
local createFunctionSender = TS.import(script, script.Parent.Parent, "function", "createFunctionSender").createFunctionSender
local createGuardMiddleware = TS.import(script, script.Parent.Parent, "middleware", "createGuardMiddleware").createGuardMiddleware
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local getNamespaceConfig = TS.import(script, script.Parent.Parent, "util", "getNamespaceConfig").getNamespaceConfig
local function createGenericHandler(globalName, namespaceName, receiverPrefix, senderPrefix, metadata, config, signals, createMethod)
	local handler = {}
	local _set = {}
	for _, _v in metadata.incomingIds do
		_set[_v] = true
	end
	local receiverNameSet = _set
	local _set_1 = {}
	for _, _v in metadata.outgoingIds do
		_set_1[_v] = true
	end
	local senderNameSet = _set_1
	local _set_2 = {}
	local _array = {}
	local _length = #_array
	local _array_1 = metadata.incomingIds
	local _Length = #_array_1
	table.move(_array_1, 1, _Length, _length + 1, _array)
	_length += _Length
	local _array_2 = metadata.outgoingIds
	table.move(_array_2, 1, #_array_2, _length + 1, _array)
	for _, _v in _array do
		_set_2[_v] = true
	end
	for name in _set_2 do
		local configMiddleware = config.middleware[name]
		local incomingMiddleware = if configMiddleware ~= nil then table.clone(configMiddleware) else {}
		local isReceiver = receiverNameSet[name] ~= nil
		local isSender = senderNameSet[name] ~= nil
		local effectiveName = if namespaceName ~= nil then `{namespaceName}/{name}` else name
		local networkInfo = {
			eventType = "Function",
			name = effectiveName,
			globalName = globalName,
		}
		if not config.disableIncomingGuards and isReceiver then
			local guards = metadata.incoming[name]
			assert(guards)
			local _arg0 = createGuardMiddleware(name, guards[1], guards[2], networkInfo, config.warnOnInvalidGuards, signals, SkipBadRequest)
			table.insert(incomingMiddleware, 1, _arg0)
		end
		local receiver = if isReceiver then createFunctionReceiver({
			namespace = globalName,
			debugName = name,
			id = if isSender then `{receiverPrefix}{effectiveName}` else effectiveName,
			networkInfo = networkInfo,
			incomingMiddleware = incomingMiddleware,
		}) else nil
		local sender = if isSender then createFunctionSender({
			namespace = globalName,
			debugName = name,
			id = if isReceiver then `{senderPrefix}{effectiveName}` else effectiveName,
			networkInfo = networkInfo,
			responseMiddleware = if config.disableIncomingGuards then nil else function(player, value, resolve, reject)
				local returnGuard = metadata.outgoing[name]
				if returnGuard and not returnGuard(value) then
					reject(NetworkingFunctionError.InvalidResult)
					signals:fire("onBadResponse", player or Players.LocalPlayer, {
						networkInfo = networkInfo,
						value = value,
					})
				else
					resolve(value)
				end
			end,
		}) else nil
		handler[name] = createMethod(config, receiver, sender)
	end
	for _, namespaceId in metadata.namespaceIds do
		local namespace = metadata.namespaces[namespaceId]
		handler[namespaceId] = createGenericHandler(globalName, if namespaceName ~= nil then `{namespaceName}/{namespaceId}` else namespaceId, receiverPrefix, senderPrefix, namespace, getNamespaceConfig(config, namespaceId), signals, createMethod)
	end
	return handler
end
return {
	createGenericHandler = createGenericHandler,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="45">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createNetworkingFunction</string>
										<string name="ScriptGuid">{a925daf3-bfcb-43d2-a532-727c0223f7ab}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local createSignalContainer = TS.import(script, script.Parent.Parent, "util", "createSignalContainer").createSignalContainer
local createGenericHandler = TS.import(script, script.Parent, "createGenericHandler").createGenericHandler
local createServerMethod = TS.import(script, script.Parent, "createServerMethod").createServerMethod
local createClientMethod = TS.import(script, script.Parent, "createClientMethod").createClientMethod
local SERVER_PREFIX = "$"
local CLIENT_PREFIX = "@"
local function getDefaultConfiguration(config)
	local _object = {}
	local _left = "middleware"
	local _condition = config.middleware
	if _condition == nil then
		_condition = {}
	end
	_object[_left] = _condition
	local _left_1 = "defaultTimeout"
	local _condition_1 = config.defaultTimeout
	if _condition_1 == nil then
		_condition_1 = (if RunService:IsClient() then 30 else 10)
	end
	_object[_left_1] = _condition_1
	local _left_2 = "warnOnInvalidGuards"
	local _condition_2 = config.warnOnInvalidGuards
	if _condition_2 == nil then
		_condition_2 = RunService:IsStudio()
	end
	_object[_left_2] = _condition_2
	local _left_3 = "disableIncomingGuards"
	local _condition_3 = config.disableIncomingGuards
	if _condition_3 == nil then
		_condition_3 = false
	end
	_object[_left_3] = _condition_3
	return _object
end
local function createNetworkingFunction(globalName)
	local signals = createSignalContainer()
	local server
	local client
	return {
		createServer = function(self, config, meta)
			if RunService:IsRunning() and not RunService:IsServer() then
				return nil
			end
			if server == nil then
				server = createGenericHandler(globalName, nil, SERVER_PREFIX, CLIENT_PREFIX, meta, getDefaultConfiguration(config), signals, createServerMethod)
			end
			return server
		end,
		createClient = function(self, config, meta)
			if RunService:IsRunning() and not RunService:IsClient() then
				return nil
			end
			if client == nil then
				client = createGenericHandler(globalName, nil, CLIENT_PREFIX, SERVER_PREFIX, meta, getDefaultConfiguration(config), signals, createClientMethod)
			end
			return client
		end,
		registerHandler = function(self, key, callback)
			return signals:connect(key, callback)
		end,
	}
end
return {
	createNetworkingFunction = createNetworkingFunction,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b5</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="46">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createServerMethod</string>
										<string name="ScriptGuid">{92520a31-8e70-4a7d-95e0-b7471794fa8b}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local NetworkingFunctionError = TS.import(script, script.Parent.Parent, "function", "errors").NetworkingFunctionError
local timeoutPromise = TS.import(script, script.Parent.Parent, "util", "timeoutPromise").timeoutPromise
local function createServerMethod(config, receiver, sender)
	local method = {
		invoke = function(self, player, ...)
			local args = { ... }
			return self:invokeWithTimeout(player, config.defaultTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, player, timeout, ...)
			local args = { ... }
			local _sender = sender
			assert(_sender, "This is not a sender remote.")
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), sender:invokeClient(player, unpack(args)) })
		end,
		setCallback = function(self, callback)
			local _receiver = receiver
			assert(_receiver, "This is not a receiver remote.")
			receiver:setServerCallback(callback)
		end,
		predict = function(self, player, ...)
			local args = { ... }
			local _receiver = receiver
			assert(_receiver, "This is not a receiver remote.")
			return receiver:invoke(player, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			return method:invoke(player, unpack(args))
		end,
	})
	return method
end
return {
	createServerMethod = createServerMethod,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b6</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="47">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">middleware</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b7</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="48">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createGuardMiddleware</string>
										<string name="ScriptGuid">{3f99be81-c67a-40b7-9eb7-8944bbfdd4fd}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local function createGuardMiddleware(name, fixedParameters, restParameter, networkInfo, warnOnInvalid, signals, failureValue)
	return function(processNext)
		return function(player, ...)
			local args = { ... }
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < math.max(#fixedParameters, #args)) then
						break
					end
					local guard = fixedParameters[i + 1] or restParameter
					if guard and not guard(args[i + 1]) then
						if warnOnInvalid then
							if player then
								warn(`'{player}' sent invalid arguments for event '{name}' (arg #{i}):`, args[i + 1])
							else
								warn(`Server sent invalid arguments for event '{name}' (arg #{i}):`, args[i + 1])
							end
						end
						signals:fire("onBadRequest", player or Players.LocalPlayer, {
							networkInfo = networkInfo,
							argIndex = i,
							argValue = args[i + 1],
						})
						return failureValue
					end
				end
			end
			return processNext(player, unpack(args))
		end
	end
end
return {
	createGuardMiddleware = createGuardMiddleware,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="49">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createMiddlewareProcessor</string>
										<string name="ScriptGuid">{920baa84-992a-4805-b98e-d43320b4063b}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local function createMiddlewareProcessor(middlewareFactories, networkInfo, finalize)
	local middleware = {}
	if not middlewareFactories or #middlewareFactories == 0 then
		middleware[1] = finalize
	else
		for i = #middlewareFactories - 1, 0, -1 do
			local factory = middlewareFactories[i + 1]
			local processNext = middleware[i + 2] or finalize
			middleware[i + 1] = factory(TS.async(function(player, ...)
				local args = { ... }
				return processNext(player, unpack(args))
			end), networkInfo)
		end
	end
	return TS.async(function(player, ...)
		local args = { ... }
		return middleware[1](player, unpack(args))
	end)
end
return {
	createMiddlewareProcessor = createMiddlewareProcessor,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003b9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="50">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">skip</string>
										<string name="ScriptGuid">{b85c6b9a-78a0-40ea-868e-b6631a06898b}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local Skip = {
	__index = function()
		return nil
	end,
	__newindex = function()
		return nil
	end,
	__tostring = function()
		return `Networking.Skip`
	end,
}
setmetatable(Skip, Skip)
-- This is a special skip type used to instruct Flamework to reject with a value of "BadRequest"
-- This does affect equality, though, so it can only be returned from the very first middleware
-- to avoid other middleware from being able to inspect it.
local SkipBadRequest = {}
setmetatable(SkipBadRequest, Skip)
return {
	Skip = Skip,
	SkipBadRequest = SkipBadRequest,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ba</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="51">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">util</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003bb</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="52">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createSignalContainer</string>
										<string name="ScriptGuid">{73f623a9-8c02-4e2c-995f-652eeddd69b3}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local function createSignalContainer()
	local signals = {}
	return {
		fire = function(self, name, ...)
			local args = { ... }
			local _name = name
			local signal = signals[_name]
			if signal then
				signal:Fire(unpack(args))
			end
		end,
		connect = function(self, name, callback)
			local _name = name
			local signal = signals[_name]
			if not signal then
				local _exp = name
				signal = Signal.new()
				local _signal = signal
				signals[_exp] = _signal
			end
			return signal:Connect(callback)
		end,
	}
end
return {
	createSignalContainer = createSignalContainer,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003bc</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="53">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getNamespaceConfig</string>
										<string name="ScriptGuid">{1d790a60-84a7-4c94-935f-43d27520bc4d}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * Creates a new config with the namespace's middleware at the top level.
	 
]]
local function getNamespaceConfig(config, namespaceId)
	local _object = table.clone(config)
	setmetatable(_object, nil)
	_object.middleware = config.middleware[namespaceId] or {}
	return _object
end
return {
	getNamespaceConfig = getNamespaceConfig,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003bd</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="54">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">timeoutPromise</string>
										<string name="ScriptGuid">{b1b8246b-af24-4369-a2fb-9f9969a81a92}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local function timeoutPromise(timeout, rejectValue)
	return TS.Promise.delay(timeout):andThen(function()
		return TS.Promise.reject(rejectValue)
	end)
end
return {
	timeoutPromise = timeoutPromise,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003be</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="55">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">@rbxts</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003bf</UniqueId>
					</Properties>
					<Item class="Folder" referent="56">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">bin</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c0</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="57">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{26a938d2-6c7b-4334-b6b3-eb09e776478f}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * Tracks connections, instances, functions, threads, and objects to be later destroyed.
	 
]]
local Bin
do
	Bin = setmetatable({}, {
		__tostring = function()
			return "Bin"
		end,
	})
	Bin.__index = Bin
	function Bin.new(...)
		local self = setmetatable({}, Bin)
		return self:constructor(...) or self
	end
	function Bin:constructor()
	end
	function Bin:add(item)
		local node = {
			item = item,
		}
		if self.head == nil then
			self.head = node
		end
		if self.tail then
			self.tail.next = node
		end
		self.tail = node
		return item
	end
	function Bin:destroy()
		while self.head do
			local item = self.head.item
			if type(item) == "function" then
				item()
			elseif typeof(item) == "RBXScriptConnection" then
				item:Disconnect()
			elseif type(item) == "thread" then
				task.cancel(item)
			elseif item.destroy ~= nil then
				item:destroy()
			elseif item.Destroy ~= nil then
				item:Destroy()
			elseif item.disconnect ~= nil then
				item:disconnect()
			elseif item.Disconnect ~= nil then
				item:Disconnect()
			end
			self.head = self.head.next
		end
		-- list is now empty, so we can clear the tail
		self.tail = nil
	end
	function Bin:isEmpty()
		return self.head == nil
	end
end
return {
	Bin = Bin,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c1</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="58">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">compiler-types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c2</UniqueId>
						</Properties>
						<Item class="Folder" referent="59">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c3</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="60">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">jsnatives</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c4</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="61">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{6a805db0-240c-47b2-b7a6-c61f18b07b2d}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Proxy = TS.import(script, script, "proxy").default
local JSON = TS.import(script, script, "json").default
local Object = TS.import(script, script, "object").Object
local ArrayUtils = TS.import(script, script, "array_utils").default
local Number = TS.import(script, script, "number").default
local Error = TS.import(script, script, "error")
local Symbol = TS.import(script, script, "symbol").default
local SetUtils = TS.import(script, script, "set_utils").default
local String = TS.import(script, script, "string").default
local inspect = TS.import(script, script, "inspect").default
local console = TS.import(script, script, "console").default
local encodeUriComponent = TS.import(script, script, "encodeUriComponent").default
local _timers = TS.import(script, script, "timers")
local setTimeout = _timers.setTimeout
local clearTimeout = _timers.clearTimeout
local setInterval = _timers.setInterval
local clearInterval = _timers.clearInterval
return {
	Proxy = Proxy,
	Object = Object,
	JSON = JSON,
	ArrayUtils = ArrayUtils,
	Number = Number,
	Error = Error,
	Symbol = Symbol,
	String = String,
	inspect = inspect,
	console = console,
	SetUtils = SetUtils,
	encodeUriComponent = encodeUriComponent,
	setTimeout = setTimeout,
	clearTimeout = clearTimeout,
	setInterval = setInterval,
	clearInterval = clearInterval,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c5</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="62">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">array_utils</string>
									<string name="ScriptGuid">{46f85c6d-88e0-48d0-a961-764ce357100b}</string>
									<ProtectedString name="Source"><![CDATA[--!nocheck
local Object = require(script.Parent.object).Object

local ArrayUtils = {}

-- tips found at https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Array/isArray.lua
-- for me, deepcheck is in most of cases not needed, because roblox-ts's handling of arrays avoid majority of the issues
-- looking for issues to change the behavior, may change deepcheck default in future
function ArrayUtils.isArray(object, deepCheck)
  if type(object) ~= "table" then return false end

  if next(object) == nil then return true end -- empty table is an array

  local length = #object

  if length == 0 then return false end -- non 0 length with next returning something is not an array

  if deepCheck == nil or not deepCheck then
    return true -- avoid expansive calculation if deepCheck is not true or not provided
  end

  local count = 0
  local sum = 0
  for _, key in Object.keys(object) do -- use of object.keys to avoid triggering __index in proxies
    if type(key) ~= "number" then return false end
    if key % 1 ~= 0 or key < 1 or key > length then return false end
    count += 1
    sum += key
  end

  return count == length and sum == length * (length + 1) / 2
end

function ArrayUtils.concat(arrayOrValue, ...)
  local array
  if not ArrayUtils.isArray(arrayOrValue) then 
    array = { arrayOrValue }
  else
    array = Object.dup(arrayOrValue)
  end

  for i=1, select("#", ...) do
    local source = select(i, ...)
    if not ArrayUtils.isArray(source) then 
      source = { source }
    end
    for _, v in source do
      array[#array + 1] = v
    end
  end
  return array
end

function ArrayUtils.flat(array, depth)
  if depth == nil or type(depth) ~= "number" then depth = 1 end
  if not ArrayUtils.isArray(array) then return array end

  if depth < 1 then return array end
  
  local out = {}

  for _, v in array do
    if ArrayUtils.isArray(v) then
      for _, v2 in ArrayUtils.flat(v, depth - 1) do
        out[#out + 1] = v2
      end
    else
      out[#out + 1] = v
    end
  end

  return out
end

function ArrayUtils.flatMap(array, func)
  if type(func) ~= "function" then error("func must be a function") end
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  local out = {}
  for i, v in array do
    out[i] = func(v, i, array)
  end
  return ArrayUtils.flat(out)
end

function ArrayUtils.reverse(array)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  local endIndex = #array
	local index = 1
	while index < endIndex do
		array[index], array[endIndex] = array[endIndex], array[index]
		index += 1
		endIndex -= 1
	end
	return array
end

function ArrayUtils.toReversed(array)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  return ArrayUtils.reverse(Object.dup(array))
end

function ArrayUtils.slice(array, start, ends)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

                                                          -- For an array [1, 2, 3, 4, 5]
  if start == nil then start = 0 end                      -- if start is nil, set it to 0
  if type(start) ~= "number" then error("start must be a number") end
  if start < 0 then start = #array - (start * -1) end     -- if start is -2, then it's 3
  if start < 0 then start = 0 end                         -- if start is still negative, set it to 0
  if ends == nil then ends = #array - 1 end               -- if ends is nil, set it to the last index
  if type(ends) ~= "number" then error("ends must be a number") end
  if ends < 0 then ends = #array - (ends * -1) end        -- if ends is -1, then it's 4
  if ends < 0 then ends = 0 end                           -- if ends is still negative, set it to 0
  if ends > #array then ends = #array end                 -- if ends is greater than the last index, set it to the last index
  if start >= ends then return {} end                     -- if start is greater than or equal to ends, return an empty array

  -- convert js indexing to lua indexing
  start += 1
  ends += 1

  local out = {}
  for i=start, ends - 1 do
    out[#out + 1] = array[i]
  end
  return out
end

function ArrayUtils.splice(array, start, count, ...)
  if not ArrayUtils.isArray(array) then error("array must be an array") end
                                                          -- For an array [1, 2, 3, 4, 5]
  if start == nil then start = 0 end                      -- if start is nil, set it to 0
  if type(start) ~= "number" then error("start must be a number") end
  if start < 0 then start = #array - 1 - (start * -1) end -- if start is -2, then it's 3
  if start < 0 then start = 0 end                         -- if start is still negative, set it to 0
  if start > #array then start = #array end               -- if start is greater than the length of the array, set it to the length of the array
  if count == nil then count = #array - start end         -- if count is nil, set it to the difference between the length of the array and start
  if type(count) ~= "number" then error("count must be a number") end
  if count < 0 then count = 0 end                         -- if count is still negative, set it to 0
  if count > #array - start then count = #array - start end -- if count is greater than the difference between the length of the array and start, set it to the difference between the length of the array and start

  local ends = start + count - 1

  -- convert js indexing to lua indexing
  start += 1
  ends += 1

  local deleted = {}
  for i=start, ends do
    deleted[#deleted + 1] = table.remove(array, start)
  end

  for i = select("#", ...), 1, -1 do
    table.insert(array, start, (select(i, ...)))
  end
  
  return deleted
end


return {
  default = ArrayUtils,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c6</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="63">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">console</string>
									<string name="ScriptGuid">{6119bbe6-67b6-4528-a685-a6ed280673d0}</string>
									<ProtectedString name="Source"><![CDATA[-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Console/makeConsoleImpl.luau
--!nocheck
local inspect = require(script.Parent.inspect).default

local GetService = game.GetService
local attemptedGetButFailed = false
local cached: LogService? = nil

local function GetLogService(): LogService?
	if cached or attemptedGetButFailed then
		return cached
	end

	local success, value = pcall(GetService, game, "LogService")
	if not success then
		attemptedGetButFailed = true
		return nil
	end

	cached = value
	return value
end

local INDENT = "  "

local console = {}
local indentDepth = 0

local function indent()
  return string.rep(INDENT, indentDepth)
end

function console.rawLog(content, ...)
  print(content, ...)
end

function console.log(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.debug(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.info(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.warn(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  warn(indent() .. message)
end

function console.error(content, ...)
  -- JS' `console.error` doesn't interrupt execution like Lua's `error`,
  -- which is more similar to throwing an exception in JS.
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  warn(indent() .. message)
end

function console.group(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
  indentDepth = indentDepth + 1
end

function console.groupCollapsed(content, ...)
  return console.group(content, ...)
end

function console.groupEnd()
  if indentDepth > 0 then
    indentDepth = indentDepth - 1
  end
end

local startTimes: {[string]: number} = {}
function console.time(label: string?)
  local trueLabel = label or "default"
  if startTimes[trueLabel] ~= nil then
    console.warn(`Timer '{trueLabel}' already exists`)
    return
  end

  startTimes[trueLabel] = os.clock()
end
function console.timeEnd(label: string?)
  local trueLabel = label or "default"
  local finishTime = os.clock()
  local startTime = startTimes[trueLabel]

  if startTime == nil then
    console.warn(`Timer '{trueLabel}' does not exist`)
    return
  end

  console.log(`{trueLabel}: {(finishTime - startTime) * 1000} ms`)
  startTimes[trueLabel] = nil
end

function console.clear()
  local logService = GetLogService()
  if logService then
    pcall(function()
      logService:ClearOutput()
    end)
  end
end

return {
  default = console,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c7</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">encodeUriComponent</string>
									<string name="ScriptGuid">{cdcf2271-0308-47f6-80a9-21d13d84e0a3}</string>
									<ProtectedString name="Source"><![CDATA[-- reference documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
--!nocheck
local HttpService = game:GetService("HttpService")
local Error = require(script.Parent.error).default
local String = require(script.Parent.string).default

local function encodeURIComponent(value: string): string
	local valueLength = utf8.len(value)
	if valueLength == 0 or valueLength == nil then
		return ""
	end
	-- we don't exhaustively test the whole string for invalid characters like ECMA-262 15.1.3 says
	local check = String.charCodeAt(value, 1)
	if valueLength == 1 then
		if check == 0xD800 then
			error(Error.new("URI malformed"))
		end
		if check == 0xDFFF then
			error(Error.new("URI malformed"))
		end
	end
	if check >= 0xDC00 and check < 0xDFFF then
		error(Error.new("URI malformed"))
	end
	local encoded = HttpService:UrlEncode(value)
	-- reverting encoded chars which are not encoded by JS
	local result = string.gsub(
		string.gsub(
			string.gsub(
				string.gsub(
					string.gsub(
						string.gsub(
							string.gsub(string.gsub(string.gsub(encoded, "%%2D", "-"), "%%5F", "_"), "%%2E", "."),
							"%%21",
							"!"
						),
						"%%7E",
						"~"
					),
					"%%2A",
					"*"
				),
				"%%27",
				"'"
			),
			"%%28",
			"("
		),
		"%%29",
		")"
	)
	return result
end

return {
  default = encodeURIComponent,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c8</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="65">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">error</string>
									<string name="ScriptGuid">{bd77ded7-5f8a-4e0a-a8f1-1eb7ebe4357a}</string>
									<ProtectedString name="Source"><![CDATA[-- thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Error/Error.global.luau
export type Error = {name: string, message: string, stack: string?}
type Error_private = Error & {__stack: string?}

local Error = {}

local DEFAULT_NAME = "Error"
Error.__index = Error
Error.__tostring = function(self)
	-- Luau FIXME: I can't cast to Error or Object here: Type 'Object' could not be converted into '{ @metatable *unknown*, {|  |} }'
	return getmetatable(Error :: any).__tostring(self)
end

-- ROBLOX NOTE: extracted __createError function so that both Error.new() and Error() can capture the stack trace at the same depth
local function __createError(message: string?): Error
	local self = (setmetatable({
		name = DEFAULT_NAME;
		message = message or "";
	}, Error) :: any) :: Error
	Error.__captureStackTrace(self, 4)
	return self
end

function Error.new(message: string?): Error
	return __createError(message)
end

function Error.captureStackTrace(err: Error, options: ((...any) -> any)?)
	Error.__captureStackTrace(err, 3, options)
end

function Error.__captureStackTrace(err_: Error, level: number, options: ((...any) -> any)?)
	local err = err_ :: Error_private
	if typeof(options) == "function" then
		local stack = debug.traceback(nil, level)
		local functionName: string = debug.info(options, "n")
		local sourceFilePath: string = debug.info(options, "s")

		local espacedSourceFilePath = string.gsub(sourceFilePath, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
		local stacktraceLinePattern = espacedSourceFilePath .. ":%d* function " .. functionName
		local beg = string.find(stack, stacktraceLinePattern)
		local end_ = nil
		if beg ~= nil then
			beg, end_ = string.find(stack, "\n", beg + 1)
		end
		if end_ ~= nil then
			stack = string.sub(stack, end_ + 1)
		end
		err.__stack = stack
	else
		err.__stack = debug.traceback(nil, level)
	end
	Error.__recalculateStacktrace(err)
end

function Error.__recalculateStacktrace(err_: Error)
	local err = err_ :: Error_private
	local message = err.message
	local name = err.name or DEFAULT_NAME

	local errName = name .. (if message ~= nil and message ~= "" then ": " .. message else "")
	local stack = if err.__stack then err.__stack else ""

	err.stack = errName .. "\n" .. stack
end

return {
  default = setmetatable(Error, {
    __call = function(_, ...)
      return __createError(...)
    end;
    __tostring = function(self)
      if self.name ~= nil then
        if self.message and self.message ~= "" then
          return string.format("%*: %*", tostring(self.name), tostring(self.message))
        end
        return tostring(self.name)
      end
      return tostring(DEFAULT_NAME)
    end;
  })
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003c9</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="66">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">inspect</string>
									<string name="ScriptGuid">{5d8a3a0e-56c1-424f-82f1-2fb013e37306}</string>
									<ProtectedString name="Source"><![CDATA[-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Collections/inspect.luau
-- derived from these upstream sources:
-- https://github.com/graphql/graphql-js/blob/1951bce42092123e844763b6a8e985a8a3327511/src/jsutils/inspect.js
--!nocheck
local HttpService = game:GetService("HttpService")

local isArray = require(script.Parent.array_utils).default.isArray

-- local NULL = require(srcWorkspace.luaUtils.null)

-- Support for options partial implementation
-- see: https://nodejs.org/dist/latest-v16.x/docs/api/util.html#utilinspectobject-options
export type InspectOptions = {
	depth: number?,
}

type FormatOptions = {
	depth: number,
}

local MAX_ARRAY_LENGTH = 10
local DEFAULT_RECURSIVE_DEPTH = 2

-- deviation: pre-declare functions
local formatValue
local formatObjectValue
local formatArray
local formatObject
local getObjectTag

--[[
 * Used to print values in error messages.
 ]]
local function inspect(value, options: InspectOptions?): string
	local inspectOptions: InspectOptions = options or {depth = DEFAULT_RECURSIVE_DEPTH}
	local depth = inspectOptions.depth or DEFAULT_RECURSIVE_DEPTH
	inspectOptions.depth = if depth >= 0 then depth else DEFAULT_RECURSIVE_DEPTH
	return formatValue(value, {}, inspectOptions :: FormatOptions)
end

local function isIndexKey(k, contiguousLength)
	return type(k) == "number"
		and k <= contiguousLength -- nothing out of bounds
		and 1 <= k -- nothing illegal for array indices
		and math.floor(k) == k -- no float keys
end

local function getTableLength(tbl)
	local length = 1
	local value = rawget(tbl, length)
	while value ~= nil do
		length += 1
		value = rawget(tbl, length)
	end
	return length - 1
end

local function sortKeysForPrinting(a: any, b)
	local typeofA = type(a)
	local typeofB = type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if typeofA == typeofB and (typeofA == "number" or typeofA == "string") then
		return a < b
	end

	-- sort the rest by type name
	return typeofA < typeofB
end

local function getFragmentedKeys(tbl)
	local keys = {}
	local keysLength = 0
	local tableLength = getTableLength(tbl)
	for key in next, tbl do
		if not isIndexKey(key, tableLength) then
			keysLength += 1
			keys[keysLength] = key
		end
	end

	table.sort(keys, sortKeysForPrinting)
	return keys, keysLength, tableLength
end

function formatValue(value, seenValues, options: FormatOptions)
	local valueType = typeof(value)
	if valueType == "string" then
		return HttpService:JSONEncode(value)
		-- deviation: format numbers like in JS
	end

	if valueType == "number" then
		if value ~= value then
			return "NaN"
		end

		if value == math.huge then
			return "Infinity"
		end

		if value == -math.huge then
			return "-Infinity"
		end

		return tostring(value)
	end

	if valueType == "function" then
		local result = "[function"
		local functionName = debug.info(value :: (any) -> any, "n")
		if functionName ~= nil and functionName ~= "" then
			result ..= " " .. functionName
		end

		return result .. "]"
	end

	if valueType == "table" then
		-- ROBLOX TODO: parameterize inspect with the library-specific NULL sentinel. maybe function generics?
		-- if value == NULL then
		-- 	return 'null'
		-- end
		return formatObjectValue(value, seenValues, options)
	end

	return tostring(value)
end

function formatObjectValue(value, previouslySeenValues, options: FormatOptions)
	if table.find(previouslySeenValues, value) ~= nil then
		return "[Circular]"
	end

	local length = #previouslySeenValues
	local seenValues = table.move(previouslySeenValues, 1, length, 1, table.create(length + 1))
	seenValues[length + 1] = value

	if type(value.toJSON) == "function" then
		local jsonValue = value:toJSON(value)

		if jsonValue ~= value then
			return if type(jsonValue) == "string" then jsonValue else formatValue(jsonValue, seenValues, options)
		end
	end

	if isArray(value) then
		return formatArray(value, seenValues, options)
	end

	return formatObject(value, seenValues, options)
end

function formatObject(object, seenValues, options: FormatOptions)
	local mt = getmetatable(object)
	if mt and rawget(mt, "__tostring") then
		return tostring(object)
	end

	local fragmentedKeys, fragmentedKeysLength, keysLength = getFragmentedKeys(object)

	if keysLength == 0 and fragmentedKeysLength == 0 then
		return "{}"
	end
	if #seenValues > options.depth then
		return "[" .. getObjectTag(object) .. "]"
	end

	local properties = table.create(keysLength + fragmentedKeysLength)
	for index = 1, keysLength do
		local value = formatValue(object[index], seenValues, options)
		properties[index] = value
	end

	for index = 1, fragmentedKeysLength do
		local key = fragmentedKeys[index]
		local value = formatValue(object[key], seenValues, options)
		properties[keysLength + index] = key .. ": " .. value
	end

	return "{ " .. table.concat(properties, ", ") .. " }"
end

function formatArray(array: {[number]: any}, seenValues: {[number]: any}, options: FormatOptions): string
	local length = #array
	if length == 0 then
		return "[]"
	end
	if #seenValues > options.depth then
		return "[Array]"
	end

	local len = math.min(MAX_ARRAY_LENGTH, length)
	local remaining = length - len
	local items = table.create(len + 1)

	for index = 1, len do
		items[index] = formatValue(array[index], seenValues, options)
	end

	if remaining == 1 then
		items[len + 1] = "... 1 more item"
	elseif remaining > 1 then
		items[len + 1] = string.format("... %* more items", tostring(remaining))
	end

	return "[" .. table.concat(items, ", ") .. "]"
end

function getObjectTag(_object): string
	-- local tag = Object.prototype.toString
	-- 	.call(object)
	-- 	.replace("")
	-- 	.replace("")

	-- if tag == "Object" and typeof(object.constructor) == "function" then
	-- 	local name = object.constructor.name

	-- 	if typeof(name) == "string" and name ~= "" then
	-- 		return name
	-- 	end
	-- end

	-- return tag
	return "Object"
end

return {
  default = inspect,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ca</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">json</string>
									<string name="ScriptGuid">{9395673a-b9fe-4ea6-ac3a-cdd437b3bcd6}</string>
									<ProtectedString name="Source"><![CDATA[--!nocheck
local HttpService = game:GetService("HttpService")
local Object = require(script.Parent.object).Object

local JSON = {}

function JSON.stringify(data)
  return Object.toString(data)
end

function JSON.parse(data)
  return HttpService:JSONDecode(data)
end

return {
  default = JSON,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003cb</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="68">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">number</string>
									<string name="ScriptGuid">{cabcd6b3-80d7-47e7-94c3-d7e072279c72}</string>
									<ProtectedString name="Source"><![CDATA[-- many elements thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Number

local Number = {}

Number.EPSILON = 2.2204460492503e-16

Number.MAX_SAFE_INTEGER = 9007199254740991
Number.MIN_SAFE_INTEGER = -9007199254740991

Number.MAX_VALUE = 1.7976931348623157e+308
Number.MIN_VALUE = 5e-324

Number.NaN = -(0 / 0)
Number.NegativeNaN = 0 / 0

Number.NEGATIVE_INFINITY = -math.huge
Number.POSITIVE_INFINITY = math.huge

Number.isFinite = function(value: number): boolean
	return type(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
end

Number.isInteger = function(value: number): boolean
	return Number.isFinite(value) and value == math.floor(value)
end

Number.isNaN = function(value: number): boolean
	return type(value) == "number" and value ~= value
end

Number.isSafeInteger = function(value: number): boolean
	return Number.isInteger(value) and value >= Number.MIN_SAFE_INTEGER and value <= Number.MAX_SAFE_INTEGER
end

-- in difference of roblox's implementations, toExponential is a prototyme methods, so, we normally are sure that the value is a number
-- we consider a nil fractionDigits as 10, like js, that expands a maximum fractionDigits is undefined
Number.toExponential = function(value: number, fractionDigits: number?): string | nil
	local num = value

  if fractionDigits == nil then fractionDigits = 10 end
  fractionDigits = math.clamp(fractionDigits :: number, 0, 100) --clamping, not crashing, even if js crashes, it avoids unexpected errors

	local formatString
	if fractionDigits == nil then
		formatString = "%e"
	else
		formatString = "%." .. tostring(fractionDigits) .. "e"
	end

	return string.gsub(string.gsub(string.gsub(string.format(formatString, num), "%+0", "+"), "%-0", "-"), "0*e", "e")
end

function extractFloatNumberFromString(value: string): string
  return value:match("^ *[-+]?%d+%.?%d*[eE][-+]?%d+") or value:match("^ *[-+]?%d*%.?%d+")
end


Number.parseFloat = function(value: unknown): number
	if type(value) == "string" then
		return tonumber(extractFloatNumberFromString(value)) or Number.NaN
	elseif type(value) == "number" then
		return value
	end

	return Number.NaN
end

local radix_chars = { "0","1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" }

function extractIntegerNumberFromString(value: string, radix: number?): string
  if radix ~= nil then radix = math.clamp(radix :: number, 2, 36) end
  
  -- extraxt 0x, 0o, 0b prefixes and manages it with radix
  local temp = nil
  if radix == nil or radix == 16 then temp = value:match("^%s*0x(.*)") end
  if temp then 
    if radix == nil then radix = 16 end
    if radix == 16 then value = temp end
  else
    if radix == nil or radix == 8 then temp = value:match("^%s*0o(.*)") end
    if temp then 
      if radix == nil then radix = 8 end
      if radix == 8 then value = temp end
    else
      if radix == nil or radix == 2 then temp = value:match("^%s*0b(.*)") end
      if temp then 
        if radix == nil then radix = 2 end
        if radix == 2 then value = temp end
      end
    end
  end

  if radix == nil then radix = 10 end

  local r = "^%s*([0-"
  if radix < 10 then r = r .. radix_chars[radix :: number] else r = r .. "9" end

  if(radix > 10) then
    r = r .. "a-" .. radix_chars[radix :: number]
    r = r .. "A-" .. radix_chars[radix :: number]:upper()
  end

  r = r .. "]+)"

  return value:match(r), radix
end

Number.parseInt = function(value: unknown, radix: number?): number
	if type(value) == "string" then
		return tonumber(extractIntegerNumberFromString(value, radix)) or Number.NaN
	elseif type(value) == "number" then
		return math.floor(value)
	end

	return Number.NaN
end

Number.toFixed = function(value: number, digits: number?): string
  if type(value) ~= "number" then
    return "nan"
  end

  return string.format("%." .. (digits or 0) .. "f", value)
end

Number.toString = function(value: number, radix: number?): string
  if radix == nil then radix = 10 end
  radix = math.clamp(radix :: number, 2, 36)

  if value == Number.NaN then return "nan" end
  if value == Number.NegativeNaN then return "-nan" end
  if value == Number.NEGATIVE_INFINITY then return "-infinity" end
  if value == Number.POSITIVE_INFINITY then return "infinity" end

  if radix == 10 then return tostring(value) end

  local isNegative = value < 0
  value = math.abs(value)

  local integerPart = math.floor(value)
  local fractionalPart = value - integerPart

  local result = ""
  if isNegative then result = "-" end

  -- integer part
  local intString = ""
  if integerPart == 0 then intString = "0"
  else
    while integerPart > 0 do
      intString = radix_chars[integerPart % radix + 1] .. intString
      integerPart = math.floor(integerPart / radix)
    end
  end

  result = result .. intString

  -- fractional part
  if fractionalPart > 0 then
    result = result .. "."
    local fractionalString = ""
    while fractionalPart > 0 and #fractionalString < 16 do
      fractionalPart = fractionalPart * radix
      local digit = math.floor(fractionalPart)
      fractionalString = fractionalString .. radix_chars[digit + 1]
      fractionalPart = fractionalPart - digit
    end
    result = result .. fractionalString
  end

  return result
end


return {
  default = setmetatable(Number, {
    __call = function(_, value: unknown)
      if type(value) == "number" then
          return value
      elseif type(value) == "string" then
        return Number.parseFloat(value)
      elseif type(value) == "boolean" then
        return value and 1 or 0
      elseif type(value) == "table" then
        if #value::{any} == 1 then
          return Number.parseFloat((value::{any})[1])
        end
      end

      return Number.NaN
    end
  }),
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003cc</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="69">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">object</string>
									<string name="ScriptGuid">{653daf60-8c6e-4cab-89a9-9be29c08f859}</string>
									<ProtectedString name="Source"><![CDATA[---@diagnostic disable: undefined-global
--!nocheck
local HttpService = game:GetService("HttpService")

local function objK(key, value) return key end
local function objV(key, value) return value end
local function objE(key, value) return {key, value} end
local function mapObject(object, withKeys, withValues)
  local assigner = withKeys and withValues and objE or (withKeys and objK or (withValues and objV or nil))
  local res = table.create(#object)
  for k, v in object do
    res[#res + 1] = assigner(k, v)
  end
  return res
end

local function keysFromMeta(object)
  local meta = getmetatable(object)
  local fun = nil
  if meta == false then -- protected metatable
    fun = object["$$KEYS"]
  elseif meta ~= nil then
    fun = meta.__keys
  end
  if fun then -- if the function is not nil, we can use it to get the keys
    return fun(object)
  end
  return nil
end

local function keysFromMetaOrObject(object)
  local keys = keysFromMeta(object)
  if keys ~= nil then
    return keys
  end
  return mapObject(object, true, false) -- we normally map the object otherwise
end

local Object = {}

function Object.create(inherited)
  if type(inherited) ~= "table" and inherited ~= nil then error("Inherited must be an object or nil") end
  if inherited == nil then return {} end
  if type(inherited) ~= "table" then error("Inherited must be an object") end
  local obj = {}
  setmetatable(obj, { __index = inherited })
  return obj
end

function Object.keys(object)
  if type(object) ~= "table" then error("object must be a table") end
  return keysFromMetaOrObject(object)
end

function Object.entries(object)
  if type(object) ~= "table" then error("object must be a table") end
  local keys = keysFromMeta(object)
  if keys ~= nil then
    local entries = table.create(#object)
    for _, k in keys do
      entries[#entries + 1] = { k, object[k] }
    end
    return entries
  else
    return mapObject(object, true, true)
  end
end

function Object.values(object)
  if type(object) ~= "table" then error("object must be a table") end
  local keys = keysFromMeta(object)
  if keys ~= nil then
    local values = table.create(#object)
    for _, k in keys do
      values[#values + 1] = object[k]
    end
    return values
  else
    return mapObject(object, false, true)
  end
end

function Object.fromEntries(entries)
  if type(entries) ~= "table" then error("entries must be a table") end
  local obj = Object.create(#entries)
  for _, k in Object.keys(entries) do
    local entry = entries[k]
    if type(entry) ~= "table" then error("entry must be a table with 1 and 2 keys") end
    obj[entry[1]] = entry[2]
  end
  return obj
end

function Object.assign(target, ...)
  if type(target) ~= "table" then error("target must be a table") end
  for i = 1, select("#", ...) do
    local source = select(i, ...)
    if type(source) ~= "table" then error("source must be a table") end
    for _, k in Object.keys(source) do
      local v = source[k]
      target[k] = v
    end
  end
  return target
end

function Object.hasOwn(object, key)
  if type(object) ~= "table" then error("object must be a table") end
  return object[key] ~= nil and object[key] ~= Object[key]
end

function isObjectOrProxyNotAnyClass(object)
  if type(object) ~= "table" then return false end    -- not a table
  if getmetatable(object) == nil then return true end -- not has no meta
  if object["$$PROXY"] ~= nil then return true end    -- has meta but is a proxy
  return false
end

function Object.dup(object, deep, cache)
  if not isObjectOrProxyNotAnyClass(object) then return object end -- cannot duplicate complex objects
	local result = table.create(#object)
	for _, k in Object.keys(object) do
    local v = object[k]
    if deep and type(v) == "table" then
      if cache == nil then cache = {} end
      if cache[v] ~= nil then
        result[k] = cache[v]
      else
        local copy = Object.dup(v, deep, cache)
        cache[v] = copy
        result[k] = copy
      end
    else
      result[k] = v
    end
	end
	return result
end

-- better thanks to: https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/is.lua
function Object.is(a, b)
  if a == b then
    return a ~= 0 or 1 / a == 1 / b
  end
  return a ~= a and b ~= b
end

-- found thanks to https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/freeze.lua
function Object.freeze(object, deep)
  if type(object) ~= "table" then return object end
  if deep then
    for _, k in Object.keys(object) do
      object[k] = Object.freeze(object[k], deep)
    end
  end
  return table.freeze(object)
end

function Object.isFrozen(object)
  return table.isfrozen(object)
end



-- tips found thanks to https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/preventExtensions.lua
-- as no "configuration" exists in lua, the only things to do is preventing adding properties
function Object.preventExtensions(object)
  if type(object) ~= "table" then return object end
  return setmetatable(object, {
    __newindex = function(_, k) -- with extensions prevented, a property CAN be deleted, but not added
      error("Cannot add new properties to an object that has extensions prevented.")
    end,
    __metatable = false
  })
end

function Object.seal(object)
  if type(object) ~= "table" then return object end
  local keys = {}
  for _, k in Object.keys(object) do
    keys[k] = true
  end
  local function keysGetter()
    return keys
  end
  return setmetatable(object, {
    __index = function(_, k)
      if k == "$$KEYS" then
        return keysGetter
      end
      return nil
    end,
    __newindex = function(_, k)
      if not keys[k] then -- a key that was in object before can be set to nil and re-added, we are not considering keys has been deleted
        error("Cannot add new properties to an object that has extensions prevented.")
      end
    end,
    __metatable = false
  })
end

function Object.equals(a, b, deep)
	-- a[k] == b[k]
	for _, k in Object.keys(a) do
		local av = a[k]
		local bv = b[k]
		if av ~= bv then -- same table references dont need to be compared 
      if type(av) == "table" and type(bv) == "table" and deep then
        -- deeply compare the tables if deep is true
        local result = Object.equals(av, bv, deep)
        if not result then
          return false
        end
      else
        return false
      end
		end
	end

	-- extra keys in b
	for _, k in Object.keys(b) do
		if a[k] == nil then return false end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(Object.dup(data, true))
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.isCallable(object)
  return type(object) == "function" or (
    type(object) == "table" and
    getmetatable(object) ~= nil and 
    type(getmetatable(object).__call) == "function" and (
      getmetatable(object).__callable == nil or getmetatable(object).__callable()
    )
  )
end

function Object.excludeTypes(value, types, deep)
  if not isObjectOrProxyNotAnyClass(value) then return value end -- cannot exclude types on complex objects
  local nextIndex, nextValue = next(types)
  if nextIndex == nil then return value end
  if type(nextValue) ~= "boolean" then --not a set yet
    local typesArr = types
    types = {}
    for _, t in typesArr do types[t] = true end
  elseif type(nextValue) ~= "string" and type(nextValue) ~= "boolean" then -- not a a transformed set or a string array
    error("types must be an array of strings")
  end
  for _, k in Object.keys(value) do
    local v = value[k]
    if type(v) == "table" and deep then
      value[k] = Object.excludeTypes(v, types, deep)
    end
    if types[type(v)] then
      value[k] = nil
    end
  end
  return value
end

Object.diffDeletedSymbol = {}

function Object.diff(current, other, deep)
  if not isObjectOrProxyNotAnyClass(current) or not isObjectOrProxyNotAnyClass(other) then 
    if current == other then return nil end
    return current
  end
  local diffed = Object.create(nil)
  local set = Object.create(nil)
  for _, k in Object.keys(current) do set[k] = true end
  for _, k in Object.keys(other) do set[k] = true end
  for k in set do
    local cv = current[k]
    local ov = other[k]
    if type(cv) == "table" and type(ov) == "table" and deep then
      local result = Object.diff(cv, ov, deep)
      if not Object.isEmpty(result) then
        diffed[k] = result
      end
    elseif cv == nil and ov ~= nil then
      diffed[k] = Object.diffDeletedSymbol
    elseif cv ~= ov then
      diffed[k] = cv
    end
  end
  return diffed
end

function Object.patch(current, diff, deep)
  if not isObjectOrProxyNotAnyClass(current) or not isObjectOrProxyNotAnyClass(diff) then return current end
  for _, k in Object.keys(diff) do
    local v = diff[k]
    if v == Object.diffDeletedSymbol then
      current[k] = nil
    elseif type(v) == "table" and type(current[k]) == "table" and deep then
      current[k] = Object.patch(current[k], v, deep)
    else
      current[k] = v
    end
  end
  return current
end
return { 
  Object = Object,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003cd</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="70">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">proxy</string>
									<string name="ScriptGuid">{eaa41a35-f368-4ce2-8edf-f7e82119fbb0}</string>
									<ProtectedString name="Source"><![CDATA[--!nocheck
local ObjectModule = require(script.Parent.object)
local Object = ObjectModule.Object
local Proxy = {}

Proxy.new = function (target, hooks, raw, metatableDefaults)
  if(type(target) ~= "table") then error("Target must be a table") end
  if(type(hooks) ~= "table") then error("Hooks must be a table") end
  if(type(raw) ~= "table" and raw ~= nil) then error("Raw must be a table or nil") end
  if(type(metatableDefaults) ~= "table" and metatableDefaults ~= nil) then error("Metatable defaults must be a table or nil") end

  if raw == nil then
    raw = {}
  end

  if metatableDefaults == nil then
    metatableDefaults = {}
  end

  metatableDefaults.__keys = function(proxy)
    if hooks.ownKeys then
      return hooks.ownKeys(target, proxy)
    else
      return Object.keys(target)
    end
  end

  metatableDefaults.__index = function(proxy, key)
    if key == "$$KEYS" then -- in case of protected metatable, we need to return the keys of the proxy using this reference
      return metatableDefaults.__keys
    end
    if key == "$$PROXY" then
      return proxy
    end

    if hooks.get then
      return hooks.get(target, key, proxy)
    else
      return target[key]
    end
  end

  metatableDefaults.__newindex = function(proxy, key, value)
    if hooks.set then
      local success = hooks.set(target, key, value, proxy)
      if not success then
        error("[PROXYERROR] Failed to set value on target object")
      end
    else
      target[key] = value
    end
  end

  metatableDefaults.__callable = function()
    if hooks.apply then
      return true
    else
      return false -- even if target is callable, it will not be callable through the proxy
    end
  end

  metatableDefaults.__call = function(proxy, ...)
    if hooks.apply then
      return hooks.apply(target, proxy, ...)
    else
      return target(...)
    end
  end

  metatableDefaults.__len = function(proxy)
    if hooks.len then
      return hooks.len(target, proxy)
    else
      return #target
    end
  end

  metatableDefaults.__iter = function(proxy)
    if hooks.iter then
      return hooks.iter(target, proxy)
    end
    local keys = metatableDefaults.__keys(proxy)
    local i = 0
    return function(lastKey)
      if lastKey ~= nil and lastKey ~= keys[i] then
        --retrieving the current last key to replace the index
        for j = 1, #keys do
          if keys[j] == lastKey then
            i = j
            break
          end
        end
      end
      i = i + 1
      if i <= #keys then
        return keys[i], proxy[keys[i]]
      end
      return nil
    end, proxy
  end

  return setmetatable(raw, metatableDefaults)
end

return {
  default = Proxy,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003ce</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="71">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">set_utils</string>
									<string name="ScriptGuid">{cae1beb7-5978-4128-8360-e681e50b4b14}</string>
									<ProtectedString name="Source"><![CDATA[local SetUtils = {}

function SetUtils.union(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    result[key] = true
  end
  for key in set2 do
    result[key] = true
  end
  return result
end

function SetUtils.intersection(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    if set2[key] then
      result[key] = true
    end
  end
  return result
end

function SetUtils.difference(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    if not set2[key] then
      result[key] = true
    end
  end
  return result
end

function SetUtils.symmetricDifference(set1: {[any]: true}, set2: {[any]: true})
  return SetUtils.union(SetUtils.difference(set1, set2), SetUtils.difference(set2, set1))
end

function SetUtils.isSubsetOf(set1: {[any]: true}, set2: {[any]: true})
  for key in set1 do
    if not set2[key] then
      return false
    end
  end
  return true
end

function SetUtils.isSupersetOf(set1: {[any]: true}, set2: {[any]: true})
  return SetUtils.isSubsetOf(set2, set1)
end

function SetUtils.isDisjointFrom(set1: {[any]: true}, set2: {[any]: true})
  for key in set1 do
    if set2[key] then
      return false
    end
  end
  return true
end

return {
  default = SetUtils,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003cf</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="72">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">string</string>
									<string name="ScriptGuid">{a7e142e2-755a-4c93-935c-7aab46ef24d8}</string>
									<ProtectedString name="Source"><![CDATA[-- many tips thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/String
--!nocheck
local Number = require(script.Parent.number).default


local String = {}

function String.charCodeAt(str: string, index: (number | string)?): number
  if type(str) ~= "string" then error("str must be a string") end
  if type(index) ~= "number" then index = tonumber(index) end
  if index == nil then error("index must be a number") end

  if index < 0 or index > #str - 1 then return Number.NaN end

  index += 1 -- convert to lua indexing

  local offset = utf8.offset(str, index)

  if offset == nil or offset > #str then return Number.NaN end

  return utf8.codepoint(str, offset) or Number.NaN
end


function String.endsWith(str: string, search: unknown, position: (number | string)?): boolean
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if search == "" then return true end
  if type(str) ~= "string" then error("str must be a string") end
  if type(position) ~= "number" then position = tonumber(position) or #str end
  if position < #search then return false end
  if position > #str then position = #str end

  local pos = position - #search + 1

  return string.find(str, search, pos, true) == pos
end

function String.startsWith(str: string, search: unknown, position: (number | string)?): boolean
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if search == "" then return true end
  if type(str) ~= "string" then error("str must be a string") end
  if type(position) ~= "number" then position = tonumber(position) or 0 end
  if position < 0 then position = 0 end
  if position > #str then position = #str end

  position += 1 -- convert to lua indexing

  return string.find(str, search, position, true) == position
end

function searchInit(str: string, search: string, position: number, reverse: boolean): number
  if type(search) ~= "string" then search = tostring(search) or "" end
  if type(position) ~= "number" then position = tonumber(position) end
  if position == nil then position = if reverse then #str else 0 end
	if search == "" then return math.clamp(position, 0, #str) end
  position += 1 -- convert to lua indexing

  if reverse then
    if position > #str then position = #str end
    if position < 1 then return -1 end
  else
    if position < 1 then position = 1 end
    if position > #str then return -1 end
  end

  return str, search, position
end

function String.indexOf(str: string, _search: unknown, _position: (string | number)?): number
  local strOrReturnPos, search, position = searchInit(str, _search, _position, false)
  if strOrReturnPos ~= str then return strOrReturnPos end

	for i = position, #str do
		if string.sub(str, i, i + #search - 1) == search then return i - 1 end
	end

	return -1
end

function String.lastIndexOf(str: string, _search: unknown, _position: (string | number)?): number
  local strOrReturnPos, search, position = searchInit(str, _search, _position, true)
  if strOrReturnPos ~= str then return strOrReturnPos end

	for i = position, 1, -1 do
		if string.sub(str, i, i + #search - 1) == search then return i - 1 end
	end

	return -1
end

function String.findOr(str: string, patternTable: {string}, position: (string | number)?): (number | nil, string | nil)
  if type(str) ~= "string" then error("str must be a string") end
  if type(patternTable) ~= "table" then error("patternTable must be a table") end
  if type(position) ~= "number" then position = tonumber(position) or 0 end
  position += 1 -- convert to lua indexing

	local foundString = nil
  local lowestIndexFound = #str
	for _, value in patternTable do
		local start, ends = string.find(str, value, position)
		if start ~= nil then
      if start < lowestIndexFound then
        foundString = string.sub(str, start, ends)
        lowestIndexFound = start
      end
		end
	end

  return lowestIndexFound - 1, foundString
end

function String.includes(str: string, substring: unknown, position: (string | number)?): boolean
  return String.indexOf(str, substring, position) ~= -1
end

function String.slice(str: string, start: (number | string)?, ends: (number | string)?): string
  if type(str) ~= "string" then error("str must be a string") end
  if type(start) ~= "number" then start = tonumber(start) or 0 end
  if type(ends) ~= "number" then ends = tonumber(ends) or #str - 1 end

  if start < 0 then start = #str - (start * -1) end
  if ends < 0 then ends = #str - 1 - (ends * -1) end
 
  start = math.clamp(start, 0, #str-1)
  ends = math.clamp(ends, 0, #str-1)

  if start > ends then return "" end

  return string.sub(str, start + 1, ends + 1)
end

function String.substring(str: string, start: (number | string)?, length: (number | string)?): string
  if type(str) ~= "string" then error("str must be a string") end
  if type(start) ~= "number" then start = tonumber(start) or 0 end
  if type(length) ~= "number" then length = tonumber(length) or #str - start end

  return string.sub(str, start + 1, start + length)
end

function String.split(str: string, separator: unknown, limit: (number | string)?): {string}
  if type(str) ~= "string" then error("str must be a string") end
  if type(separator) ~= "string" then separator = tostring(separator) end
  if type(limit) ~= "number" then limit = tonumber(limit) or Number.MAX_SAFE_INTEGER end
  if separator == nil then return {str} end
  if limit <= 0 then return {} end
  local result = {}

  if separator == "" then 
    for v in str:gmatch(".") do
      table.insert(result, v)
    end
    return result
  end

  repeat
    local start, ends = string.find(str, separator)
    if start ~= nil then
      table.insert(result, string.sub(str, 1, start - 1))
      str = string.sub(str, ends + 1)
    end
  until #result >= limit or start == nil

  table.insert(result, str)

  return result
end

function String.trimEnd(str: string): string
  if type(str) ~= "string" then error("str must be a string") end
  return (string.gsub(str, "[%s]+$", ""))
end

function String.trimStart(str: string): string
  if type(str) ~= "string" then error("str must be a string") end
  return (string.gsub(str, "^[%s]+", ""))
end

function String.trim(str: string): string
  return String.trimEnd(String.trimStart(str))
end

function String.replaceAll(str: string, search: unknown, replace: unknown | ((string) -> string) | {[string]: string}, limit: (number | string)?): string  
  if type(str) ~= "string" then error("str must be a string") end
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if type(replace) ~= "string" and type(replace) ~= "function" and type(replace) ~= "table" then replace = tostring(replace) end
  if replace == nil then error("replace must be a string or a function or a table") end
  if type(limit) ~= "number" then limit = tonumber(limit) end -- can be nil, so no need to check

  return (string.gsub(str, search, replace, limit))
end

function String.replace(str: string, search: unknown, replace: unknown | ((string) -> string) | {[string]: string}): string
  return String.replaceAll(str, search, replace, 1)
end

String.rep = string.rep

function String.search(str: string, pattern: unknown): number
  if type(pattern) ~= "string" then pattern = tostring(pattern) end
  if pattern == nil then error("pattern must be a string") end
  return (string.find(str, pattern) or -1)
end

function String.at(str: string, index: (number | string)): string
  if type(index) ~= "number" then index = tonumber(index) end
  if index == nil then error("index must be a number") end
  if index < 0 then index = #str + index end
  if index < 0 then return "" end
  if index > #str then return "" end
  index += 1 -- convert to lua indexing
  return string.sub(str, index, index)
end

function String.concat(...: unknown): string
  local result = ""
  for i=1, select("#", ...) do
    local value = select(i, ...)
    if type(value) ~= "string" then value = tostring(value) or "" end
    result = result .. value
  end
  return result
end

function padInit(str: string, length: unknown, fillString: string): string
  if type(length) ~= "number" then length = tonumber(length) or 0 end
  if type(fillString) ~= "string" then fillString = tostring(fillString) or " " end
  if fillString == "" then fillString = " " end
  if length <= #str then return str end
  local generateLength = length - #str
  return string.sub(string.rep(fillString, math.ceil(generateLength / #fillString)), 1, generateLength)
end

function String.padEnd(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  return str .. strOrFillString
end

function String.padStart(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  return strOrFillString .. str
end

function String.padBoth(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  local side = str.sub(strOrFillString, 1, math.floor(#strOrFillString / 2))
  return side .. str .. side
end

String.toLowerCase = string.lower
String.toUpperCase = string.upper

function String.toCamelCase(str: string): string
  return (str:gsub("[%s%-_]+(%w)", string.upper):gsub("^%u", string.lower))
end

function String.toPascalCase(str: string): string
  return (str:gsub("[%s%-_]+(%w)", string.upper):gsub("^%l", string.upper))
end

function String.toSnakeCase(str: string): string
  return str:gsub("%u", function(c) return "_" .. c end):gsub("[%s%-_]+(%w)", function(c) return "_" .. c end):gsub("^_+", ""):lower()
end

function String.toKebabCase(str: string): string
  return str:gsub("%u", function(c) return "-" .. c end):gsub("[%s%-_]+(%w)", function(c) return "-" .. c end):gsub("^-+", ""):lower()
end

function String.toTitleCase(str: string): string
  return (str:gsub("%u", function(c) return " " .. c:upper() end):gsub("[%s%-_]+(%w)", function(c) return " " .. c:upper() end):gsub("^%s+(%l)", string.upper))
end

function String.toSentenceCase(str: string): string
  return (str:gsub("%u", function(c) return " " .. c:lower() end):gsub("[%s%-_]+(%w)", function(c) return " " .. c:lower() end):gsub("^%s+(%l)", string.upper))
end

return {
  default = String,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="73">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">symbol</string>
									<string name="ScriptGuid">{5928d253-614a-47ea-aa4a-c5c46a4bc9c1}</string>
									<ProtectedString name="Source"><![CDATA[-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Symbol

export type Symbol = typeof(newproxy(true)) & {[string]: any}
local Registry = {} :: {[string]: Symbol}

local isSymbol = nil

local Symbol = {
	new = function(name: string?): Symbol
		local self = newproxy(true) :: any

		local wrappedName = "Symbol()"
		if name then
			wrappedName = string.format("Symbol(%*)", name)
		end

		getmetatable(self).__tostring = function()
			return wrappedName
		end

		getmetatable(self).__index = function(_, key)
			if key == isSymbol then
				return true
			end
			return nil
		end

    getmetatable(self).__metatable = false

		return (self :: any) :: Symbol
	end,

  isSymbol = function(value: any)
    return type(value) == "table" and value[isSymbol] == true
  end,
}

isSymbol = Symbol.new("is-symbol")

Symbol["for"] = function(key: string)
  if Registry[key] == nil then
    Registry[key] = Symbol.new(key)
  end
  return Registry[key]
end

return {
  default = setmetatable(Symbol, {
    __call = function(self, key: string)
      return Symbol.new(key)
    end
  }),
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="74">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">timers</string>
									<string name="ScriptGuid">{cd43d67f-1cfc-4f6b-aa75-f1a1bbbbb2a3}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Symbol = TS.import(script, script.Parent, "symbol").default
local timeouts = setmetatable({}, {
	__mode = "k",
})
local intervals = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	 * Clears a timeout.
	 * @param sym - The symbol of the timeout to clear.
	 
]]
local function clearTimeout(sym)
	local _condition = sym ~= nil
	if _condition then
		local _sym = sym
		local _result = timeouts[_sym]
		if _result ~= nil then
			_result = _result()
		end
		_condition = _result == false
	end
	if _condition then
		local _sym = sym
		timeouts[_sym] = nil
	end
end
--[[
	*
	 * Sets a timeout.
	 * @param cb - The callback to execute after the timeout.
	 * @param ms - The timeout in milliseconds.
	 * @returns The symbol of the timeout.
	 
]]
local function setTimeout(cb, ms)
	if ms == nil then
		ms = 0
	end
	local sym = Symbol("timeout")
	local active = true
	task.delay(ms / 1000, function()
		if not active then
			return nil
		end
		cb(sym)
	end)
	timeouts[sym] = function()
		active = false
		return active
	end
	return sym
end
--[[
	*
	 * Sets an interval.
	 * @param cb - The callback to execute after the interval.
	 * @param ms - The interval in milliseconds.
	 * @returns The symbol of the interval.
	 
]]
local function setInterval(cb, ms)
	if ms == nil then
		ms = 0
	end
	local sym = Symbol("interval")
	local active = true
	local run
	run = function()
		return task.delay(ms / 1000, function()
			if not active then
				return nil
			end
			cb(sym)
			run()
		end)
	end
	intervals[sym] = function()
		active = false
		return active
	end
	return sym
end
--[[
	*
	 * Clears an interval.
	 * @param sym - The symbol of the interval to clear.
	 
]]
local function clearInterval(sym)
	local _condition = sym ~= nil
	if _condition then
		local _sym = sym
		local _result = intervals[_sym]
		if _result ~= nil then
			_result = _result()
		end
		_condition = _result == false
	end
	if _condition then
		local _sym = sym
		intervals[_sym] = nil
	end
end
return {
	clearTimeout = clearTimeout,
	setTimeout = setTimeout,
	setInterval = setInterval,
	clearInterval = clearInterval,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d2</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="75">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">maid</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d3</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="76">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Maid</string>
								<string name="ScriptGuid">{d256e5d8-53bf-4f63-80a6-b923541c815b}</string>
								<ProtectedString name="Source"><![CDATA[---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = {}

	self._tasks = {}

	return setmetatable(self, Maid)
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (thread)           Manages a thread
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
        	return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif type(oldTask) == "thread" then
			local cancelled
			if coroutine.running() ~= oldTask then
				cancelled = pcall(function()
					task.cancel(oldTask)
				end)
			end

			if not cancelled then
				task.defer(function()
					task.cancel(oldTask)
				end)
			end
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif type(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				local toCancel = job
				task.defer(function()
					task.cancel(toCancel)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d4</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="77">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">object-utils</string>
							<string name="ScriptGuid">{a318c6bf-6b90-418f-af92-a9df15ce2bb6}</string>
							<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d5</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="78">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">services</string>
							<string name="ScriptGuid">{5c53dfd6-dd7e-4287-a67b-af0f346e08d1}</string>
							<ProtectedString name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="79">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">signal</string>
							<string name="ScriptGuid">{999103b0-dbbc-48f3-9751-8e63e39b423b}</string>
							<ProtectedString name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({ Bindable = Instance.new("BindableEvent") }, Signal)
end

function Signal:Connect(Callback)
	return self.Bindable.Event:Connect(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Once(Callback)
	return self.Bindable.Event:Once(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:ConnectParallel(Callback)
	return self.Bindable.Event:ConnectParallel(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Fire(...)
	local Arguments = { ... }
	local n = select("#", ...)

	self.Bindable:Fire(function()
		return table.unpack(Arguments, 1, n)
	end)
end

function Signal:Wait()
	return self.Bindable.Event:Wait()()
end

function Signal:Destroy()
	self.Bindable:Destroy()
end

return Signal
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d7</UniqueId>
						</Properties>
					</Item>
					<Item class="Folder" referent="80">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">t</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d8</UniqueId>
						</Properties>
						<Item class="Folder" referent="81">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">lib</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003d9</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="82">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ts</string>
									<string name="ScriptGuid">{4709b5a7-0ffa-4d92-b127-3a39f5fb3305}</string>
									<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is any of the given literal values

	@param literals The literals to check against

	@returns A function that will return true if the condition is passed
**--]]
function t.literalList(literals)
	-- optimization for primitive types
	local set = {}
	for _, literal in ipairs(literals) do
		set[literal] = true
	end
	return function(value)
		if set[value] then
			return true
		end
		for _, literal in ipairs(literals) do
			if literal == value then
				return true
			end
		end

		return false
	end
end

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.unionList(literals)
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param checks The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.unionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		return t.unionList({ ... })
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param checks The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersectionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		return t.intersectionList({ ... })
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003da</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="83">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003db</UniqueId>
						</Properties>
						<Item class="Folder" referent="84">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">include</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003dc</UniqueId>
							</Properties>
							<Item class="Folder" referent="85">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">generated</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003dd</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerScriptService" referent="86">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000036e</UniqueId>
		</Properties>
		<Item class="Folder" referent="87">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">TS</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003de</UniqueId>
			</Properties>
			<Item class="Folder" referent="88">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">components</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003df</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="89">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">network</string>
					<string name="ScriptGuid">{9e42a393-e50a-4672-b160-df9ca1f4f2a3}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network")
local GlobalEvents = _network.GlobalEvents
local GlobalFunctions = _network.GlobalFunctions
local Events = GlobalEvents:createServer({}, {
	incomingIds = {},
	incoming = {},
	incomingUnreliable = {},
	outgoingIds = {},
	outgoingUnreliable = {},
	namespaceIds = {},
	namespaces = {},
})
local Functions = GlobalFunctions:createServer({}, {
	incomingIds = {},
	incoming = {},
	outgoingIds = {},
	outgoing = {},
	namespaceIds = {},
	namespaces = {},
})
return {
	Events = Events,
	Functions = Functions,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e0</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="90">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">runtime</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{ce3cb39a-1170-40d6-bd07-63110fed289b}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "ServerScriptService", "TS", "components" } })
Flamework._addPaths({ { "ServerScriptService", "TS", "services" } })
Flamework._addPaths({ { "ReplicatedStorage", "TS", "components" } })
Flamework.ignite()
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e1</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="91">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">services</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000003e2</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXe4b9bcc7b70b4460880b9c2cc4e14be0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tool-testing-service</string>
						<string name="ScriptGuid">{f1f38d9e-eb10-46ba-be05-bf88332939c7}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Service = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Service
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local SkillRunner = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "skill-builder").SkillRunner
local TestSkill = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "skills", "test-skill").TestSkill
local ToolGiver
do
	ToolGiver = setmetatable({}, {
		__tostring = function()
			return "ToolGiver"
		end,
	})
	ToolGiver.__index = ToolGiver
	function ToolGiver.new(...)
		local self = setmetatable({}, ToolGiver)
		return self:constructor(...) or self
	end
	function ToolGiver:constructor()
	end
	function ToolGiver:onStart()
		Players.PlayerAdded:Connect(function(p)
			local _ = p.Character or (p.CharacterAdded:Wait())
			local tool = Instance.new("Tool")
			tool.Activated:Connect(function()
				print("activated!")
				SkillRunner.new(TestSkill, {
					character = tool.Parent,
				})
			end)
			tool.Name = "Test Skill"
			tool.RequiresHandle = false
			tool.Parent = p:WaitForChild("Backpack")
		end)
	end
	do
		-- (Flamework) ToolGiver metadata
		Reflect.defineMetadata(ToolGiver, "identifier", "server/services/tool-testing-service@ToolGiver")
		Reflect.defineMetadata(ToolGiver, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) ToolGiver decorators
Reflect.decorate(ToolGiver, "$:flamework@Service", Service, {})
return {
	ToolGiver = ToolGiver,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900007609</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX6afdd1eeb83046e68596ee5a9ff7065d">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000036f</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBXaf4541feb4174e54ae477fa01c6ee7f1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000375</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000388</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX2d40c0dadec249b1aa882cbb6096969e">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"><![CDATA[BAAAABQAAABSQlhfQmFja3VwQnJpZ2h0bmVzcwUAAIA/HgAAAFJCWF9CYWNrdXBFeHBvc3Vy
ZUNvbXBlbnNhdGlvbgUAAAAAIQAAAFJCWF9MaWdodGluZ0NvbXBhdGliaWxpdHlNaWdyYXRl
ZAMBIAAAAFJCWF9PcmlnaW5hbFRlY2hub2xvZ3lPbkZpbGVMb2FkBAEAAAA=]]></BinaryString>
			<float name="Brightness">1.98124921</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LightingStyle">0</token>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<bool name="PrioritizeLightingQuality">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000043c</UniqueId>
		</Properties>
		<Item class="ColorGradingEffect" referent="RBX92ac778c968c44ffaef03619b9ae9e1e">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ColorGrading</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="TonemapperPreset">1</token>
				<UniqueId name="UniqueId">36522965a6c9538f084c4fbe00000394</UniqueId>
			</Properties>
		</Item>
		<Item class="BloomEffect" referent="RBX6ebc142b97784cda8575bfeeaa4fd82d">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="Intensity">0</float>
				<string name="Name">Bloom</string>
				<float name="Size">24</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="Threshold">0.949999988</float>
				<UniqueId name="UniqueId">36522965a6c9538f084c4fbe00000395</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="VideoService" referent="RBXf65c6db3ff1c48849585dfa351ac6015">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000043f</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX135dce7fd7d64522a11d914d06093f1f">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900000440</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXa5656818ec164f6e9f2ff419c1f0eeca">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="ThrottlePhysicsToRealtime">true</bool>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d90000598f</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX9e7f3df71a6641dc87fbbbe200954324">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000059cf</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX1922770491c947e48ba2b99d20ff77eb">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d9000059da</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX24cfdbb28b374a4ebe69d247a5bd6bfe">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5cf9ac95759887ba084b95d900007089</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>